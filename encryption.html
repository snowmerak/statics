<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>대화형 암호화 알고리즘 탐색기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Visualization & Content Choices: 
        1. History: Vertical Timeline (HTML/CSS).
        2. Modern Algos: Interactive diagrams (HTML/CSS/JS) for AES rounds, Hash properties, AEAD flows, DH Key Exchange, ECC Point Ops; Code examples (Go/TS).
        3. PQC: Info Cards, NIST Level explanation (HTML/CSS text).
        4. Comparison: Bar Charts (Chart.js), Parameter Table (HTML).
        5. Implementation & Operation: Info Cards, lists (HTML/CSS text).
        6. Future Tech (FHE, ZKP, LWC, Blockchain-deep): Info Cards, conceptual flow diagrams (HTML/CSS/JS), ZKP types comparison.
        Library/Method: Chart.js for charts; Vanilla JS and Tailwind CSS for all other interactions and layouts. NO SVG/Mermaid. -->
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-800 */
        }
        .section-title {
            color: #0891b2; /* cyan-600 */
        }
        .nav-button {
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
            padding-bottom: 0.5rem;
            margin-bottom: -2px; /* Align with border */
        }
        .nav-button.active {
            border-bottom-color: #0891b2; /* cyan-600 */
            color: #0e7490; /* cyan-700 */
            font-weight: 600;
        }
        .content-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: transform 0.2s ease-in-out;
            display: flex; 
            flex-direction: column; 
        }
        .content-card:hover {
            transform: translateY(-5px);
        }
        .content-card-body {
            flex-grow: 1; 
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 40vh;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .timeline-item {
            position: relative;
            padding-bottom: 2rem;
            padding-left: 2rem;
            border-left: 2px solid #cbd5e1; /* slate-300 */
        }
        .timeline-item:last-child {
            border-left: 2px solid transparent;
        }
        .timeline-dot {
            position: absolute;
            left: -0.5rem;
            top: 0.25rem;
            height: 1rem;
            width: 1rem;
            border-radius: 9999px;
            background-color: white;
            border: 3px solid #0891b2; /* cyan-600 */
        }
        .tab-button.active {
            background-color: #0891b2; /* cyan-600 */
            color: white;
        }
        .interactive-diagram {
            border: 1px solid #e2e8f0; /* slate-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: #f1f5f9; /* slate-100 */
            min-height: 150px;
        }
        .aes-step, .aead-flow-step, .blake3-node, .future-tech-step, .pkc-step {
            padding: 0.5rem;
            margin: 0.25rem;
            border: 1px solid #94a3b8; /* slate-400 */
            border-radius: 0.25rem;
            background-color: white;
            transition: background-color 0.3s, transform 0.3s;
        }
        .aes-step.active, .aead-flow-step.active, .blake3-node.active, .future-tech-step.active, .pkc-step.active {
            background-color: #06b6d4; /* cyan-500 */
            color: white;
            transform: scale(1.05);
        }
        .data-block {
            display: inline-block;
            width: 40px; height: 40px;
            line-height: 40px; text-align: center;
            border: 1px solid #64748b; /* slate-500 */
            margin: 2px; font-size: 0.8rem;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #0891b2;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #334155;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 10; 
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.875rem;
            line-height: 1.25rem;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .code-example-container {
            margin-top: 1rem;
            border-top: 1px solid #e2e8f0;
            padding-top: 1rem;
        }
        .code-example-toggle {
            background-color: #0891b2; 
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            margin-right: 0.5rem;
            transition: background-color 0.2s;
        }
        .code-example-toggle:hover {
            background-color: #0e7490; 
        }
        .code-block {
            background-color: #1e293b; 
            color: #e2e8f0; 
            padding: 0.75rem;
            border-radius: 0.375rem;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem; 
            line-height: 1.4;
            margin-top: 0.5rem;
            max-height: 300px; 
        }
        .code-block pre {
            margin: 0;
        }
        .code-block code .comment {
            color: #94a3b8; 
        }
        .sub-section-title {
            font-size: 1.25rem; 
            font-weight: 700; 
            color: #0e7490; 
            margin-bottom: 0.75rem; 
            padding-bottom: 0.25rem; 
            border-bottom: 1px solid #e2e8f0; 
        }
        .ecc-point {
            width: 10px; height: 10px; background-color: #fb7185; border-radius: 50%; position: absolute;
        }
    </style>
</head>
<body class="antialiased">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold section-title mb-2">대화형 암호화 알고리즘 탐색기</h1>
            <p class="text-lg text-slate-600">암호학의 역사, 현대 알고리즘, 구현 고려사항, 미래 기술까지 심층적으로 조망합니다.</p>
        </header>

        <nav id="main-nav" class="flex flex-wrap justify-center space-x-2 sm:space-x-4 md:space-x-8 mb-12 border-b border-slate-200 text-sm sm:text-base">
            <button class="nav-button active" data-target="timeline">암호학의 발전사</button>
            <button class="nav-button" data-target="modern-algos">현대 핵심 알고리즘</button>
            <button class="nav-button" data-target="pqc">양자내성암호 동향</button>
            <button class="nav-button" data-target="implementation">구현 및 운영</button>
            <button class="nav-button" data-target="future-tech">미래 기술</button>
            <button class="nav-button" data-target="comparison">종합 비교</button>
        </nav>

        <main>
            <section id="timeline-section" class="main-section">
                <div class="max-w-4xl mx-auto">
                    <h2 class="text-3xl font-bold text-center mb-8 section-title">암호학의 발전사: 주요 이정표</h2>
                    <p class="text-center text-slate-600 mb-12">정보 보호를 위한 인류의 지적 여정은 고대 암호 체계에서 시작하여, 수학적 이론과 컴퓨팅 기술의 발전에 힘입어 현대의 정교한 암호 시스템으로 진화해왔습니다. 본 연대기는 암호학의 주요 변곡점과 핵심적인 기술 발전을 조명하며, 현재와 미래 암호 기술의 토대를 이해하는 데 도움을 줄 것입니다.</p>
                    <div id="timeline-container"></div>
                </div>
            </section>

            <section id="modern-algos-section" class="main-section hidden">
                <h2 class="text-3xl font-bold text-center mb-8 section-title">현대 핵심 암호 알고리즘 심층 분석</h2>
                <p class="text-center text-slate-600 mb-12">현대 디지털 정보 시스템의 보안은 다양한 암호학적 프리미티브에 의존합니다. 본 섹션에서는 데이터 무결성을 위한 해시 함수, 기밀성 보장을 위한 대칭키 암호, 키 교환 및 디지털 서명을 위한 공개키 암호, 그리고 기밀성, 무결성, 인증을 통합 제공하는 AEAD 구성의 주요 알고리즘들을 심층적으로 분석합니다. 각 탭을 통해 이들의 작동 원리, 보안 특성, 주요 응용 분야, 인터랙티브 시각화 및 코드 예제를 살펴보십시오.</p>
                <div class="flex flex-wrap justify-center mb-8 border border-slate-200 rounded-lg p-1 max-w-xl mx-auto bg-slate-100">
                    <button class="tab-button flex-1 p-2 rounded-md transition-colors duration-300 active" data-algo-target="hash">해시 함수</button>
                    <button class="tab-button flex-1 p-2 rounded-md transition-colors duration-300" data-algo-target="symmetric">대칭키 암호</button>
                    <button class="tab-button flex-1 p-2 rounded-md transition-colors duration-300" data-algo-target="public-key">공개키 암호</button>
                    <button class="tab-button flex-1 p-2 rounded-md transition-colors duration-300" data-algo-target="aead">AEAD</button>
                </div>
                <div id="algo-content-container"></div>
            </section>

            <section id="pqc-section" class="main-section hidden">
                <h2 class="text-3xl font-bold text-center mb-8 section-title">미래 암호 패러다임: 양자내성암호(PQC) 동향</h2>
                <p class="text-center text-slate-600 mb-12">대규모 양자컴퓨터의 출현은 현재 널리 사용되는 공개키 암호 체계(RSA, ECC 등)의 기반이 되는 수학적 문제(소인수분해, 이산 로그)를 효율적으로 해결할 수 있어, 디지털 인프라 전반에 심각한 보안 위협을 야기합니다. 이에 대응하기 위해, 양자컴퓨터로도 해독하기 어려운 새로운 암호학적 기반을 갖춘 양자내성암호(PQC)의 연구 및 표준화가 미국 NIST 주도로 활발히 진행되고 있습니다. 본 섹션에서는 PQC의 필요성과 주요 표준화 동향을 소개합니다.</p>
                <div class="grid md:grid-cols-2 gap-8 items-start">
                    <div class="content-card p-6">
                        <div class="content-card-body">
                            <h3 class="text-xl font-bold text-cyan-700 mb-3">양자 컴퓨팅의 암호학적 위협</h3>
                            <p class="text-slate-600 mb-4 text-sm leading-relaxed">1994년 피터 쇼어(Peter Shor)가 제안한 쇼어 알고리즘은 현재 공개키 암호 시스템의 근간인 소인수분해 및 이산 로그 문제의 주기성(periodicity)을 효율적으로 찾아 해결할 수 있음을 이론적으로 증명했습니다. 이는 RSA, ECC 등 핵심 공개키 암호의 보안성을 근본적으로 위협합니다.</p>
                            <div class="p-4 bg-yellow-50 border border-yellow-200 rounded-lg mb-4">
                               <h4 class="font-semibold text-yellow-800">PQC의 양자 내성 근거</h4>
                               <p class="text-yellow-700 text-sm">PQC 알고리즘은 대부분 <span class="tooltip">격자(Lattice) 기반 문제<span class="tooltiptext">다차원 공간에 규칙적으로 배열된 점들의 집합인 격자에서, 특정 벡터(Shortest Vector Problem)나 가까운 벡터(Closest Vector Problem)를 찾는 문제.</span></span>, 코드 기반, 다변수 다항식, 해시 기반, 아이소제니 기반 등의 수학적 난제에 기반합니다. 이러한 문제들은 쇼어 알고리즘이 공략하는 주기성 구조를 가지고 있지 않거나, 다른 방식으로 양자 공격에 저항성을 갖도록 설계되어 현재까지 알려진 양자 알고리즘으로는 효율적인 해법이 존재하지 않습니다.</p>
                            </div>
                            <div class="p-4 bg-red-50 border border-red-200 rounded-lg">
                                <h4 class="font-semibold text-red-800">"지금 수집하고, 나중에 해독" (Harvest Now, Decrypt Later) 시나리오</h4>
                                <p class="text-red-700 text-sm">공격자가 현재 암호화된 데이터를 대량으로 수집·저장한 후, 미래에 강력한 양자컴퓨터를 이용하여 이를 해독하는 전략입니다. 국가 기밀, 금융 정보, 개인 식별 정보 등 장기적인 기밀 유지가 필수적인 데이터에 대해 중대한 위협으로 간주됩니다.</p>
                            </div>
                        </div>
                    </div>
                    <div class="content-card p-6">
                        <div class="content-card-body">
                            <h3 class="text-xl font-bold text-cyan-700 mb-3">NIST PQC 표준화 동향</h3>
                            <p class="text-slate-600 mb-2 text-sm leading-relaxed">미국 국립표준기술연구소(NIST)는 PQC 표준화 과정을 통해 다음과 같은 알고리즘들을 1차 표준으로 선정했습니다 (2024년 8월 FIPS 발표 기준):</p>
                            <ul class="space-y-2 mb-4">
                                <li class="p-2 bg-cyan-50 rounded-md text-sm"><strong>ML-KEM (FIPS 203):</strong> CRYSTALS-KYBER 기반 키 캡슐화 메커니즘.</li>
                                <li class="p-2 bg-cyan-50 rounded-md text-sm"><strong>ML-DSA (FIPS 204):</strong> CRYSTALS-Dilithium 기반 디지털 서명.</li>
                                <li class="p-2 bg-cyan-50 rounded-md text-sm"><strong>SLH-DSA (FIPS 205):</strong> SPHINCS+ 기반 상태 비저장 해시 기반 디지털 서명.</li>
                            </ul>
                            <hr class="my-4 border-slate-200">
                            <h4 class="font-semibold text-cyan-800 mb-2">NIST 보안 레벨 (Security Levels) 이해하기</h4>
                            <p class="text-slate-600 text-sm mb-2 leading-relaxed">NIST는 PQC 알고리즘의 보안 강도를 평가하고 비교하기 위해 5가지 보안 레벨을 정의했습니다. 이 레벨들은 기존의 잘 알려진 암호(AES, SHA)를 공격하는 데 필요한 계산 자원과 PQC 알고리즘을 공격하는 데 필요한 자원을 비교하여 설정됩니다.</p>
                            <ul class="space-y-1 text-sm list-disc list-inside text-slate-600">
                                <li><strong>레벨 1:</strong> <span class="tooltip">AES-128<span class="tooltiptext">128비트 키를 사용하는 AES. 이 수준의 공격은 단기적으로 가장 먼저 현실화될 수 있는 양자 위협으로 간주됩니다.</span></span>을 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                                <li><strong>레벨 2:</strong> <span class="tooltip">SHA-256/SHA3-256<span class="tooltiptext">256비트 해시 함수의 충돌 저항성. 또는 AES-192와 유사한 작업량으로 간주되기도 합니다.</span></span>을 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                                <li><strong>레벨 3:</strong> <span class="tooltip">AES-192<span class="tooltiptext">192비트 키를 사용하는 AES. 레벨 1보다 높은 보안성을 제공합니다.</span></span>를 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                                <li><strong>레벨 4:</strong> <span class="tooltip">SHA-384/SHA3-384<span class="tooltiptext">384비트 해시 함수의 충돌 저항성. 또는 AES-256과 유사한 작업량으로 간주되기도 합니다.</span></span>을 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                                <li><strong>레벨 5:</strong> <span class="tooltip">AES-256<span class="tooltiptext">256비트 키를 사용하는 AES. 현재 고전 컴퓨팅 환경에서 매우 강력한 보안 수준입니다.</span></span>을 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                            </ul>
                            <p class="text-xs text-slate-500 mt-2 leading-relaxed">예를 들어, ML-KEM-512는 레벨 1, ML-KEM-768은 레벨 3, ML-KEM-1024는 레벨 5에 해당합니다.</p>
                        </div>
                    </div>
                </div>
            </section>

            <section id="implementation-section" class="main-section hidden">
                <h2 class="text-3xl font-bold text-center mb-8 section-title">암호 기술 구현 및 운영</h2>
                <p class="text-center text-slate-600 mb-12">암호 알고리즘의 이론적 안전성만큼 중요한 것은 실제 시스템에서의 안전한 구현과 운영입니다. 잘못된 구현이나 운영은 강력한 알고리즘조차 무력화시킬 수 있습니다. 본 섹션에서는 암호 기술 적용 시 핵심적으로 고려해야 할 사항들을 다룹니다.</p>
                <div class="space-y-8">
                    <div class="content-card p-6">
                        <h3 class="sub-section-title">키 관리 (Key Management)</h3>
                        <p class="text-sm text-slate-600 mb-4 leading-relaxed">키는 암호 시스템의 "마스터 키"와 같습니다. 키 관리의 실패는 전체 시스템의 실패로 이어집니다. 안전한 키 관리는 다음 생명주기 전반에 걸쳐 이루어져야 합니다:</p>
                        <ul class="list-disc list-inside text-sm text-slate-600 space-y-1 leading-relaxed">
                            <li><strong>생성 (Generation):</strong> 충분한 엔트로피를 가진 CSPRNG를 사용하여 예측 불가능하게 생성해야 합니다.</li>
                            <li><strong>분배 (Distribution):</strong> 키가 안전하게 대상에게 전달되어야 하며, 대칭키의 경우 특히 중요합니다.</li>
                            <li><strong>저장 (Storage):</strong> 암호화된 형태로 저장하거나, HSM(Hardware Security Module)과 같은 보안 하드웨어에 저장해야 합니다.</li>
                            <li><strong>사용 (Usage):</strong> 키 사용 범위를 최소화하고, 사용 기록을 모니터링해야 합니다.</li>
                            <li><strong>교체 (Rotation):</strong> 주기적으로 또는 키 노출 의심 시 새로운 키로 교체해야 합니다 (예: Crypto Period).</li>
                            <li><strong>파기 (Destruction):</strong> 더 이상 사용하지 않는 키는 복구 불가능하도록 안전하게 파기해야 합니다.</li>
                        </ul>
                        <p class="text-xs text-slate-500 mt-2 leading-relaxed">HSM은 키 생성, 저장, 암호 연산 등을 물리적으로 안전한 환경에서 수행하여 키를 보호하는 데 효과적입니다.</p>
                    </div>

                    <div class="content-card p-6">
                        <h3 class="sub-section-title">안전한 무작위성 확보 (Secure Randomness)</h3>
                        <p class="text-sm text-slate-600 mb-4 leading-relaxed">암호학에서 무작위성은 매우 중요합니다. 키, 초기화 벡터(IV), 논스(Nonce), 솔트(Salt) 등은 예측 불가능해야 하며, 이를 위해 암호학적으로 안전한 의사 난수 생성기(CSPRNG)를 사용해야 합니다.</p>
                        <ul class="list-disc list-inside text-sm text-slate-600 space-y-1 leading-relaxed">
                            <li><strong>엔트로피 (Entropy):</strong> CSPRNG는 예측 불가능성의 원천인 충분한 엔트로피(무작위성)를 가진 시드(seed)로 초기화되어야 합니다. 운영체제가 제공하는 엔트로피 소스(예: `/dev/random`, `crypto.getRandomValues()`)를 활용합니다.</li>
                            <li><strong>예측 불가능성 (Unpredictability):</strong> 과거 출력값으로부터 다음 출력값을 예측할 수 없어야 합니다.</li>
                            <li><strong>재현 불가능성 (Non-reproducibility):</strong> 동일한 시퀀스가 반복되지 않아야 합니다 (매우 긴 주기를 가짐).</li>
                        </ul>
                        <p class="text-xs text-slate-500 mt-2 leading-relaxed">일반적인 프로그래밍 언어의 표준 난수 생성기(예: `Math.random()`)는 암호학적 용도로 안전하지 않습니다.</p>
                    </div>
                    
                    <div class="content-card p-6">
                        <h3 class="sub-section-title">구현 시 주요 취약점 및 대응</h3>
                        <div class="grid md:grid-cols-2 gap-4">
                            <div>
                                <h4 class="font-semibold text-cyan-800 text-sm">IV/Nonce 재사용</h4>
                                <p class="text-xs text-slate-600 leading-relaxed">CTR, GCM, ChaCha20 등 스트림 암호 계열 모드에서 IV나 Nonce를 동일한 키로 재사용하면, 두 암호문의 XOR를 통해 평문 정보가 노출될 수 있는 치명적 취약점이 발생합니다. 각 암호화마다 고유한 IV/Nonce를 사용해야 합니다.</p>
                            </div>
                            <div>
                                <h4 class="font-semibold text-cyan-800 text-sm">패딩 오라클 공격</h4>
                                <p class="text-xs text-slate-600 leading-relaxed">CBC 모드에서 암호문 복호화 시 패딩 유효성 검사 오류 메시지의 차이를 이용하여 평문을 한 바이트씩 추측하는 공격입니다. AEAD 모드를 사용하거나, 오류 메시지를 일반화하여 방어할 수 있습니다.</p>
                            </div>
                            <div>
                                <h4 class="font-semibold text-cyan-800 text-sm">길이 확장 공격 (Length Extension Attack)</h4>
                                <p class="text-xs text-slate-600 leading-relaxed">SHA-1, SHA-256 등 Merkle-Damgård 구조 기반 해시 함수에서 `H(key || message)` 형태의 MAC 사용 시, 해시값과 메시지 길이를 알면 `H(key || message || padding || new_data)`를 계산할 수 있는 공격입니다. HMAC 또는 SHA-3, BLAKE2/3와 같이 강인한 구조를 사용해야 합니다.</p>
                            </div>
                             <div>
                                <h4 class="font-semibold text-cyan-800 text-sm">부적절한 알고리즘/모드/키 길이 선택</h4>
                                <p class="text-xs text-slate-600 leading-relaxed">보안 요구 수준에 맞지 않는 약한 알고리즘(예: DES, MD5), 취약한 운영 모드(예: ECB), 또는 너무 짧은 키 길이를 사용하는 것은 시스템 전체의 보안을 저해합니다. 최신 표준과 권고 사항을 따라야 합니다.</p>
                            </div>
                        </div>
                    </div>

                    <div class="content-card p-6">
                        <h3 class="sub-section-title">물리적 보안 및 부채널 공격</h3>
                        <p class="text-sm text-slate-600 mb-4 leading-relaxed">암호 알고리즘의 수학적 견고성과 별개로, 암호 연산이 수행되는 물리적 장치로부터 정보를 유출하려는 시도가 존재합니다.</p>
                        <ul class="list-disc list-inside text-sm text-slate-600 space-y-1 leading-relaxed">
                            <li><strong>부채널 공격 (Side-Channel Attacks):</strong> 암호 장치가 연산 중에 소비하는 전력, 방출하는 전자기파, 소요되는 시간 등의 물리적 특성을 분석하여 비밀키 등의 정보를 유추하는 공격입니다. (예: DPA, SPA, Timing Attack)</li>
                            <li><strong>결함 주입 공격 (Fault Injection Attacks):</strong> 암호 장치에 고의로 오류(전압 이상, 레이저 주입 등)를 발생시켜 비정상적인 출력을 유도하고, 이를 분석하여 비밀 정보를 얻어내는 공격입니다.</li>
                        </ul>
                         <p class="text-sm text-slate-600 mt-2 leading-relaxed">대응책으로는 연산 과정의 데이터를 무작위화하는 마스킹(masking), 시간차 공격을 막기 위한 연산 시간 일정화, 하드웨어적 차폐(shielding), 오류 탐지 회로 등이 연구되고 있습니다.</p>
                    </div>
                </div>
            </section>

            <section id="future-tech-section" class="main-section hidden">
                <h2 class="text-3xl font-bold text-center mb-8 section-title">미래 암호 기술의 지평</h2>
                <p class="text-center text-slate-600 mb-12">양자내성암호(PQC)가 당면 과제라면, 그 너머에는 데이터 활용 방식과 프라이버시 패러다임을 근본적으로 변화시킬 수 있는 첨단 암호 기술들이 연구되고 있습니다. 본 섹션에서는 이러한 미래 지향적 암호 기술들의 개념과 잠재력을 살펴봅니다.</p>
                <div class="space-y-8">
                    <div class="content-card p-6">
                        <h3 class="sub-section-title">완전 동형 암호 (Fully Homomorphic Encryption, FHE)</h3>
                        <p class="text-sm text-slate-600 mb-4 leading-relaxed">FHE는 데이터를 암호화된 상태 그대로 특정 연산(덧셈, 곱셈 등)을 수행하고, 그 결과를 복호화하면 평문에서 연산한 것과 동일한 결과를 얻을 수 있게 하는 획기적인 암호 기술입니다. 이는 데이터의 기밀성을 유지하면서 외부(예: 클라우드)에서 데이터 처리가 가능하게 합니다.</p>
                        <div id="fhe-flow-interactive" class="interactive-diagram mb-2"></div>
                        <ul class="list-disc list-inside text-sm text-slate-600 space-y-1 leading-relaxed">
                            <li><strong>주요 응용 분야:</strong> 프라이버시 보존 아웃소싱 컴퓨팅(클라우드에서의 민감 데이터 처리), 보안 다자간 계산, 암호화된 데이터베이스 검색, 유전체 분석 등.</li>
                            <li><strong>현재 과제:</strong> 높은 연산 오버헤드와 암호문 크기, 제한된 연산 종류 및 깊이 등이 실용화를 위한 주요 기술적 난제입니다. 최근 BFV, CKKS, TFHE 등 다양한 스킴이 제안되며 성능 개선 연구가 활발합니다.</li>
                        </ul>
                    </div>

                    <div class="content-card p-6">
                        <h3 class="sub-section-title">영지식 증명 (Zero-Knowledge Proofs, ZKP)</h3>
                        <p class="text-sm text-slate-600 mb-4 leading-relaxed">ZKP는 증명자(Prover)가 자신이 특정 명제(statement)가 참임을 알고 있다는 사실을, 해당 명제의 참/거짓 외에는 어떠한 추가 정보도 검증자(Verifier)에게 노출하지 않으면서 납득시키는 암호학적 프로토콜입니다. 이는 "어떤 것을 알고 있다는 사실" 자체를 증명하는 강력한 도구입니다.</p>
                        <div id="zkp-flow-interactive" class="interactive-diagram mb-2"></div>
                        <ul class="list-disc list-inside text-sm text-slate-600 space-y-1 leading-relaxed">
                            <li><strong>주요 특성:</strong>
                                <ul class="list-disc list-inside ml-4">
                                    <li><strong>완전성 (Completeness):</strong> 증명자의 주장이 참이면, 정직한 증명자는 항상 정직한 검증자를 납득시킬 수 있습니다.</li>
                                    <li><strong>건전성 (Soundness):</strong> 증명자의 주장이 거짓이면, 부정직한 증명자는 정직한 검증자를 납득시킬 수 없습니다 (매우 낮은 확률 제외).</li>
                                    <li><strong>영지식성 (Zero-Knowledge):</strong> 검증자는 증명자의 주장이 참이라는 사실 외에는 어떠한 추가 정보도 얻을 수 없습니다.</li>
                                </ul>
                            </li>
                            <li><strong>대화형 vs. 비대화형:</strong>
                                <ul class="list-disc list-inside ml-4">
                                    <li><strong>대화형 ZKP:</strong> 증명자와 검증자 간의 여러 라운드 상호작용이 필요합니다.</li>
                                    <li><strong>비대화형 ZKP (NIZK):</strong> 증명자가 단일 메시지(증명)를 생성하여 보내면 검증자가 이를 검증할 수 있습니다. Fiat-Shamir Heuristic 등을 사용하여 대화형 프로토콜을 비대화형으로 변환하기도 합니다.</li>
                                </ul>
                            </li>
                            <li><strong>대표적 유형 및 특징:</strong>
                                <ul class="list-disc list-inside ml-4">
                                    <li><strong>zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge):</strong> 증명 크기가 매우 작고 검증이 빠르지만, 대부분 신뢰할 수 있는 초기 설정(Trusted Setup)이 필요하며, 일부는 양자 공격에 취약할 수 있습니다.</li>
                                    <li><strong>zk-STARKs (Zero-Knowledge Scalable Transparent Argument of Knowledge):</strong> 신뢰 설정이 필요 없고(투명성), 양자내성을 가질 수 있지만, 증명 크기가 SNARKs보다 크고 검증 시간이 더 걸릴 수 있습니다.</li>
                                </ul>
                            </li>
                            <li><strong>주요 응용 분야:</strong> 블록체인 확장성 및 프라이버시(예: Zcash, StarkNet, zkSync), 익명 인증 및 신원 증명(예: 디지털 ID), 프라이버시 보존 투표, 감사 및 규정 준수 검증.</li>
                        </ul>
                    </div>

                    <div class="content-card p-6">
                         <h3 class="sub-section-title">블록체인과 암호 기술 (심층)</h3>
                         <p class="text-sm text-slate-600 mb-4 leading-relaxed">블록체인은 탈중앙화된 신뢰를 구축하기 위해 다양한 암호 기술을 정교하게 결합한 시스템입니다. 해시 함수와 디지털 서명 외에도 다음과 같은 암호학적 요소들이 핵심적인 역할을 수행합니다.</p>
                         <ul class="list-disc list-inside text-sm text-slate-600 space-y-1 leading-relaxed">
                            <li><strong>머클 트리 (Merkle Trees):</strong> 다수의 데이터를 효율적으로 해시하여 단일 루트 해시로 요약하고, 특정 데이터의 존재 여부 및 무결성을 간결한 증명(Merkle Proof)으로 검증할 수 있게 합니다. 블록 내 트랜잭션 집합 관리에 필수적입니다.</li>
                            <li><strong>암호학적 누적기 (Cryptographic Accumulators):</strong> 특정 집합에 원소가 포함되어 있음을 간결하게 증명할 수 있는 기법으로, 상태 관리나 멤버십 증명에 활용될 수 있습니다.</li>
                            <li><strong>작업 증명 (Proof-of-Work, PoW)에서의 해시:</strong> 비트코인 등에서 새로운 블록을 생성하기 위해 특정 조건을 만족하는 해시값을 찾는 경쟁적 연산 과정으로, 네트워크 보안과 블록 생성 속도 조절에 기여합니다.</li>
                            <li><strong>합의 알고리즘에서의 암호 기법:</strong> 지분 증명(PoS), 위임 지분 증명(DPoS) 등 다양한 합의 알고리즘은 난수 생성, 투표, 검증 과정에 암호학적 서명, VRF(Verifiable Random Function) 등을 활용하여 공정성과 보안을 확보합니다.</li>
                             <li><strong>스마트 컨트랙트와 보안:</strong> 스마트 컨트랙트 코드 자체의 취약점 외에도, 트랜잭션 순서, 난수 생성 등과 관련된 암호학적 문제들이 보안에 영향을 미칠 수 있습니다.</li>
                         </ul>
                    </div>
                    
                    <div class="content-card p-6">
                        <h3 class="sub-section-title">경량 암호 (Lightweight Cryptography, LWC)</h3>
                        <p class="text-sm text-slate-600 mb-4 leading-relaxed">IoT(사물인터넷) 기기, RFID 태그, 무선 센서 네트워크, 임베디드 시스템 등은 매우 제한된 계산 능력, 메모리, 전력 자원을 가집니다. 이러한 환경에서도 데이터의 기밀성, 무결성, 인증을 제공하기 위해 최적화된 암호 기술이 경량 암호입니다.</p>
                        <ul class="list-disc list-inside text-sm text-slate-600 space-y-1 leading-relaxed">
                            <li><strong>설계 목표:</strong> 낮은 에너지 소비, 작은 하드웨어/소프트웨어 구현 크기, 최소한의 RAM 사용, 적절한 수준의 보안 강도.</li>
                            <li><strong>NIST LWC 표준화:</strong> NIST는 경량 암호 표준화를 위한 공모전을 진행했으며, ASCON 알고리즘군이 최종 표준으로 선정되었습니다. ASCON은 인증 암호화 및 해시 기능을 제공합니다.</li>
                            <li><strong>주요 알고리즘 유형:</strong> 경량 블록 암호(예: PRESENT, SIMON, SPECK - 단, SIMON/SPECK은 논란이 있었음), 경량 스트림 암호, 경량 해시 함수, 경량 AEAD 등이 있습니다.</li>
                        </ul>
                        <p class="text-xs text-slate-500 mt-2 leading-relaxed">경량 암호는 성능과 보안 사이의 균형을 맞추는 것이 중요하며, 적용 환경의 특성과 보안 요구사항을 면밀히 분석하여 선택해야 합니다.</p>
                    </div>
                </div>
            </section>

            <section id="comparison-section" class="main-section hidden">
                <h2 class="text-3xl font-bold text-center mb-8 section-title">주요 암호 알고리즘 비교 분석</h2>
                <p class="text-center text-slate-600 mb-12">암호 알고리즘 선택 시 보안 강도, 연산 속도, 키 및 서명 크기 등 다양한 요소를 고려해야 합니다. 아래 자료들은 주요 현대 암호 알고리즘들의 핵심 특성을 비교하여 보여줍니다. 이를 통해 특정 응용 환경 및 보안 요구사항에 적합한 알고리즘을 선택하는 데 참고할 수 있습니다.</p>
                <div class="grid md:grid-cols-2 gap-8 mb-8">
                    <div class="content-card p-6">
                        <h3 class="text-xl font-bold text-center mb-4 text-cyan-700">고전적 보안 강도 (등가 비트 수)</h3>
                        <div class="chart-container">
                            <canvas id="securityChart"></canvas>
                        </div>
                        <p class="text-xs text-slate-500 mt-2 text-center">해시 함수의 경우 충돌 저항성 기준, 대칭키는 키 길이 기준입니다. PQC 알고리즘은 NIST 보안 레벨에 따른 등가 강도를 나타냅니다.</p>
                    </div>
                    <div class="content-card p-6">
                        <h3 class="text-xl font-bold text-center mb-4 text-cyan-700">상대적 연산 속도</h3>
                        <div class="chart-container">
                            <canvas id="speedChart"></canvas>
                        </div>
                        <p class="text-xs text-slate-500 mt-2 text-center">AES-GCM은 전용 하드웨어 가속(AES-NI) 시, ChaCha20-Poly1305는 소프트웨어 구현 시 뛰어난 성능을 보입니다. BLAKE3는 병렬 처리 능력에서 강점을 가집니다.</p>
                    </div>
                </div>
                <div class="content-card p-6 max-w-4xl mx-auto">
                    <h3 class="text-xl font-bold text-center mb-4 text-cyan-700">주요 매개변수 크기 비교 (바이트)</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm text-left text-slate-600">
                            <thead class="text-xs text-slate-700 uppercase bg-slate-100">
                                <tr>
                                    <th scope="col" class="px-6 py-3">알고리즘</th>
                                    <th scope="col" class="px-6 py-3">분류</th>
                                    <th scope="col" class="px-6 py-3">키 크기 (Public/Private)</th>
                                    <th scope="col" class="px-6 py-3">출력/서명/태그 크기</th>
                                    <th scope="col" class="px-6 py-3">IV/논스 크기</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="bg-white border-b">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">AES-256-GCM</th>
                                    <td class="px-6 py-4">AEAD</td>
                                    <td class="px-6 py-4">32 (비밀키)</td>
                                    <td class="px-6 py-4">16 (인증 태그)</td>
                                    <td class="px-6 py-4">12 (권장)</td>
                                </tr>
                                <tr class="bg-slate-50 border-b">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">ChaCha20-Poly1305</th>
                                    <td class="px-6 py-4">AEAD</td>
                                    <td class="px-6 py-4">32 (비밀키)</td>
                                    <td class="px-6 py-4">16 (인증 태그)</td>
                                    <td class="px-6 py-4">12</td>
                                </tr>
                                 <tr class="bg-white border-b">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">SHA-256</th>
                                    <td class="px-6 py-4">해시</td>
                                    <td class="px-6 py-4">-</td>
                                    <td class="px-6 py-4">32 (해시)</td>
                                    <td class="px-6 py-4">-</td>
                                </tr>
                                <tr class="bg-slate-50 border-b">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">ML-KEM-512 (NIST L1)</th>
                                    <td class="px-6 py-4">PQC KEM</td>
                                    <td class="px-6 py-4">800 / 1632</td>
                                    <td class="px-6 py-4">768 (암호문)</td>
                                    <td class="px-6 py-4">-</td>
                                </tr>
                                <tr class="bg-white">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">ML-DSA-44 (NIST L2)</th>
                                    <td class="px-6 py-4">PQC 서명</td>
                                    <td class="px-6 py-4">1312 / 2528</td>
                                    <td class="px-6 py-4">2420 (서명)</td>
                                    <td class="px-6 py-4">-</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        const timelineData = [
            { year: "기원전 400년경", title: "스키테일 암호", description: "고대 스파르타에서 사용된 전치 암호의 초기 형태로, 막대의 지름이 암호화 키 역할을 수행했습니다. 군사 통신의 기밀성 유지 목적이었습니다." },
            { year: "기원전 100-44년", title: "카이사르 암호", description: "율리우스 카이사르가 사용한 단일 문자 치환 암호로, 알파벳을 일정한 간격으로 이동시켜 암호화했습니다. 단순성으로 인해 빈도 분석에 취약했습니다." },
            { year: "16세기", title: "비즈네르 암호", description: "다중 문자 치환 암호로, 키워드를 사용하여 여러 카이사르 암호를 조합하는 방식입니다. 단일 문자 빈도 분석을 효과적으로 방어했으나, 키 길이 및 반복성에 약점이 있었습니다." },
            { year: "1940년대", title: "에니그마 기계 해독", description: "앨런 튜링을 비롯한 블레츨리 파크 연구팀이 독일군의 에니그마 암호를 해독, 제2차 세계대전의 전황에 결정적 영향을 미쳤습니다. 이는 암호 해독학의 중요성을 부각시킨 사건입니다." },
            { year: "1976년", title: "디피-헬만 키 교환", description: "최초의 실용적인 공개키 기반 키 교환 프로토콜로, 안전하지 않은 통신 채널 상에서 비밀키를 공유할 수 있는 방법을 제시하여 현대 암호학의 혁명적 전환을 이끌었습니다. 공개키 암호의 개념을 정립하고 인터넷 보안의 초석을 마련했습니다." },
            { year: "1977년", title: "DES (데이터 암호 표준) 발표", description: "미국 정부 표준으로 채택된 대칭키 블록 암호로, 56비트 키를 사용했습니다. 금융 거래 등 광범위한 분야에서 사용되었으나, 키 길이의 한계로 이후 AES로 대체되었습니다." },
            { year: "1977년", title: "RSA 알고리즘 개발", description: "리베스트, 샤미르, 애들먼이 개발한 최초의 실용적인 공개키 암호 시스템으로, 큰 수의 소인수분해 어려움에 기반합니다. 암호화 및 디지털 서명에 널리 활용되며, 공개키 암호 시대를 열었습니다." },
            { year: "1985년", title: "타원 곡선 암호 (ECC) 제안", description: "닐 코블리츠와 빅터 밀러가 각각 독립적으로 타원 곡선을 암호학에 응용하는 아이디어를 제안했습니다. RSA보다 짧은 키 길이로 유사한 보안 강도를 제공하여 효율성 측면에서 주목받기 시작했습니다." },
            { year: "1990년대 초반", title: "크립토 워 (Crypto Wars)", description: "강력한 암호 기술의 대중화와 정부의 통제 시도 사이의 논쟁이 격화된 시기입니다. PGP 공개 등이 주요 계기가 되었습니다." },
            { year: "1994년", title: "쇼어 알고리즘 발표", description: "피터 쇼어가 제안한 양자 알고리즘으로, 대규모 양자컴퓨터가 RSA, ECC 등 기존 공개키 암호를 효율적으로 해독할 수 있음을 이론적으로 증명하여 PQC 연구의 필요성을 제기했습니다." },
            { year: "1995년", title: "SHA-1 발표", description: "NIST가 발표한 160비트 출력의 해시 함수로 널리 사용되었으나, 2005년 이후 이론적 충돌 공격 가능성이 제기되고 2017년 실제 충돌이 시연되어 현재는 보안상 취약한 것으로 간주됩니다." },
            { year: "2001년", title: "AES (고급 암호 표준) 선정", description: "NIST의 공개 공모를 통해 라인달(Rijndael) 알고리즘이 DES를 대체할 차세대 대칭키 암호 표준으로 선정되었습니다. 128, 192, 256비트 키를 지원하며 현재 표준으로 사용됩니다." },
            { year: "2015년", title: "SHA-3 (Keccak) 발표", description: "NIST가 새로운 해시 함수 표준으로 Keccak 알고리즘을 선정했습니다. SHA-2와 내부 구조(스펀지 구조)가 달라 알고리즘 다양성을 확보했습니다." },
            { year: "2018년", title: "TLS 1.3 발표", description: "IETF가 발표한 최신 전송 계층 보안 프로토콜로, 보안성과 성능을 대폭 향상시켰습니다. 구형 암호 스위트를 제거하고 완전 순방향 비밀성(PFS)을 강화했습니다." },
            { year: "2024년 8월", title: "NIST PQC 1차 표준 발표 (FIPS)", description: "NIST가 양자컴퓨터 위협에 대응하기 위한 1차 양자내성암호 표준으로 ML-KEM (Kyber), ML-DSA (Dilithium), SLH-DSA (SPHINCS+)를 FIPS로 공식 발표했습니다." },
        ];

        const algoData = {
            hash: {
                title: '해시 함수: 데이터 무결성의 수호자',
                description: '암호학적 해시 함수는 임의 길이의 입력 데이터를 고정된 길이의 해시값(또는 메시지 다이제스트)으로 변환하는 단방향 함수입니다. 주요 보안 속성으로는 역상 저항성, 제2 역상 저항성, 충돌 저항성이 요구됩니다. 디지털 서명, 데이터 무결성 검증, 패스워드 저장 등 다양한 보안 응용의 핵심 구성 요소입니다. 아래 인터랙티브 요소를 통해 해시 함수의 특성을 살펴보세요.',
                algos: [
                    { 
                        name: 'SHA-256 (FIPS 180-4)', 
                        details: '256비트 해시값을 생성하는 SHA-2 계열의 대표적인 알고리즘입니다. Merkle-Damgård 구조를 기반으로 하며, 이 반복 구조는 길이 확장 공격에 취약할 수 있어 HMAC 등과 함께 사용해야 합니다. 비트코인, TLS 인증서 등에 광범위하게 사용됩니다.',
                        interactive_id: 'sha256-interactive',
                        code_examples: {
                            go: `package main
import ("crypto/sha256"; "encoding/hex"; "fmt")

func main() {
	data := []byte("안녕하세요, 암호화 세계!") 
	hasher := sha256.New()
	hasher.Write(data)
	hashBytes := hasher.Sum(nil)
	hashString := hex.EncodeToString(hashBytes)
	fmt.Printf("SHA-256 해시: %s\\n", hashString)
}`,
                            typescript: `async function sha256Example(data: string): Promise<string> {
    const dataBytes = new TextEncoder().encode(data);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBytes);
    const hashHex = Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    console.log(\`SHA-256 해시: \${hashHex}\`);
    return hashHex;
}
sha256Example("안녕하세요, 암호화 세계!");`
                        }
                    },
                    { 
                        name: 'BLAKE2 (RFC 7693)', 
                        details: 'SHA-3 경쟁 최종 후보였던 BLAKE의 후속 버전으로, HAIFA 구조에 기반하여 길이 확장 공격에 강인합니다. 특히 BLAKE2b는 64비트 플랫폼에, BLAKE2s는 32비트 이하 플랫폼에 최적화되어 있습니다. SHA-2보다 빠른 속도와 높은 유연성을 제공합니다.',
                        interactive_id: 'blake2-interactive',
                        code_examples: {
                            go: `package main
import ("fmt"; "golang.org/x/crypto/blake2b"; "encoding/hex")

func main() {
	data := []byte("BLAKE2 테스트 메시지")
	hasher, _ := blake2b.New256(nil) 
	hasher.Write(data)
	hashBytes := hasher.Sum(nil)
	fmt.Printf("BLAKE2b-256 해시: %s\\n", hex.EncodeToString(hashBytes))
}`,
                            typescript: `// TypeScript에서 BLAKE2는 표준 Web Crypto API에 포함되어 있지 않습니다.
// 일반적으로 서드파티 라이브러리(예: 'blakejs')를 사용합니다.
console.warn("TypeScript용 BLAKE2는 표준 Web Crypto API에 없습니다.");`
                        }
                    },
                    { 
                        name: 'BLAKE3', 
                        details: 'BLAKE2를 기반으로 병렬 처리 능력을 극대화한 최신 고성능 해시 함수입니다. 내부적으로 머클 트리 구조를 사용하여 멀티코어 및 SIMD 환경에서 매우 뛰어난 성능을 발휘합니다. 스트리밍 처리, 키 해싱, 키 유도, 확장 가능 출력(XOF) 등 다양한 모드를 지원합니다. 아래에서 BLAKE3의 트리 구조를 간략히 시각화하여 병렬 처리의 이점을 살펴보세요.',
                        interactive_id: 'blake3-interactive',
                        code_examples: {
                            go: `package main
import ("fmt"; "github.com/zeebo/blake3"; "encoding/hex")

func main() {
	data := []byte("BLAKE3 초고속 해시!")
	hasher := blake3.New()
	hasher.Write(data)
	hashBytes := hasher.Sum(nil)
	fmt.Printf("BLAKE3 해시: %s\\n", hex.EncodeToString(hashBytes))
}`,
                            typescript: `// TypeScript에서 BLAKE3는 표준 Web Crypto API에 포함되어 있지 않습니다.
// 일반적으로 서드파티 라이브러리(예: 'blake3')를 사용합니다.
console.warn("TypeScript용 BLAKE3는 표준 Web Crypto API에 없습니다.");`
                        }
                    },
                ]
            },
            symmetric: {
                title: '대칭키 암호: 신속한 데이터 기밀성 보장',
                description: '대칭키 암호 시스템은 암호화와 복호화 과정에 동일한 비밀키를 사용하는 방식입니다. 비대칭키 암호에 비해 연산 속도가 매우 빨라 대용량 데이터의 기밀성 보장에 효과적입니다. 그러나 키 분배 및 관리가 주요 과제입니다. 대표적인 표준으로는 AES가 있습니다. 아래 인터랙티브 요소를 통해 AES의 작동 방식과 운영 모드를 이해해 보세요.',
                algos: [
                    { 
                        name: 'AES (FIPS 197)', 
                        details: `Advanced Encryption Standard의 약자로, 현재 전 세계 표준 대칭키 블록 암호입니다. 128비트(16바이트) 고정 블록 크기로 데이터를 처리하며, 평문이 블록 크기에 맞지 않을 경우 <span class="tooltip">패딩(padding)<span class="tooltiptext">PKCS#7 패딩: 블록 암호화 시 데이터가 블록 크기의 배수가 아닐 때 사용됩니다. N 바이트가 부족하면, N이라는 값으로 N개의 바이트를 채웁니다. 예를 들어 16바이트 블록에 5바이트가 부족하면, 5라는 값 5개(0x05)로 채웁니다. 데이터가 블록 크기와 정확히 맞아도, 패딩 구분을 위해 새 블록 전체를 패딩 값(예: 0x10)으로 채웁니다.</span></span>이 필요합니다. 키 길이에 따라 AES-128, AES-192, AES-256으로 분류되며, SPN(Substitution-Permutation Network) 구조를 채택하여 여러 라운드의 변환을 반복 수행합니다. 아래에서 AES 라운드 과정을 단계별로 살펴보세요.`,
                        interactive_id: 'aes-rounds-interactive',
                        code_examples: {
                            go: `package main
import ("crypto/aes"; "crypto/cipher"; "crypto/rand"; "encoding/hex"; "fmt"; "io"; "bytes")

func pkcs7Pad(data []byte, blockSize int) []byte { /* ... */ return nil }
func pkcs7Unpad(data []byte) ([]byte, error) { /* ... */ return nil, nil }

func main() {
	key := []byte("0123456789abcdef0123456789abcdef") 
	plaintext := []byte("AES-CBC 암호화 테스트입니다.")
	block, _ := aes.NewCipher(key)
	iv := make([]byte, aes.BlockSize)
	io.ReadFull(rand.Reader, iv)
	paddedPlaintext := pkcs7Pad(plaintext, aes.BlockSize)
	ciphertext := make([]byte, len(paddedPlaintext))
	cipher.NewCBCEncrypter(block, iv).CryptBlocks(ciphertext, paddedPlaintext)
	fmt.Printf("암호문 (hex): %s\\n", hex.EncodeToString(ciphertext))
	// 복호화 로직 생략
}`,
                            typescript: `async function aesCbcExample(plainText: string): Promise<void> {
    const keyBytes = crypto.getRandomValues(new Uint8Array(32)); 
    const iv = crypto.getRandomValues(new Uint8Array(16));      
    const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, { name: "AES-CBC" }, false, ["encrypt", "decrypt"]);
    const encodedPlainText = new TextEncoder().encode(plainText);
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-CBC", iv: iv }, cryptoKey, encodedPlainText);
    console.log(\`암호문 (hex): \${Array.from(new Uint8Array(ciphertext)).map(b => b.toString(16).padStart(2, '0')).join('')}\`);
    // 복호화 로직 생략
}
aesCbcExample("AES-CBC 암호화 테스트입니다.");`
                        }
                    },
                    { 
                        name: '운영 모드 (NIST SP 800-38A)', 
                        details: '블록 암호인 AES를 실제 데이터에 적용하기 위한 방법론입니다. ECB 모드는 동일 평문 블록이 동일 암호문 블록으로 변환되어 패턴 노출에 취약합니다. CBC 모드는 이전 암호문 블록을 다음 평문 블록 암호화에 연쇄적으로 사용하여 이러한 단점을 개선합니다. 아래에서 ECB와 CBC 모드의 차이점을 시각적으로 비교해 보세요.',
                        interactive_id: 'aes-modes-interactive',
                        code_examples: null 
                    },
                ]
            },
            'public-key': {
                title: '공개키 암호: 키 교환과 디지털 서명의 핵심',
                description: '공개키 암호 시스템은 한 쌍의 키(공개키와 개인키)를 사용합니다. 공개키는 누구나 접근할 수 있지만, 개인키는 소유자만 안전하게 보관합니다. 이를 통해 안전한 키 교환, 디지털 서명, 암호화 등 다양한 기능을 제공하며, 현대 인터넷 보안의 근간을 이룹니다.',
                algos: [
                    {
                        name: '디피-헬만 키 교환 (Diffie-Hellman)',
                        details: '1976년 제안된 최초의 공개키 기반 키 교환 프로토콜입니다. 안전하지 않은 채널에서 두 당사자가 사전에 비밀 정보를 공유하지 않고도 공통의 비밀키를 설정할 수 있게 합니다. 이산 로그 문제의 어려움에 기반하며, TLS, SSH 등에서 널리 사용됩니다. 단, 자체적으로 인증 기능이 없어 중간자 공격에 취약할 수 있으므로, 실제 사용 시에는 인증서 등 추가적인 인증 메커니즘과 함께 사용됩니다.',
                        interactive_id: 'dh-interactive',
                        code_examples: {
                            go: `package main
import ("crypto/elliptic"; "crypto/rand"; "encoding/hex"; "fmt"; "log"; "math/big")

func main() {
	// NIST P-256 커브 사용 (실제 DH는 유한체 위에서 정의되나, ECC로 유사 개념 시연)
	curve := elliptic.P256()

	// Alice의 키 쌍 생성
	alicePrivKey, aliceX, aliceY, err := elliptic.GenerateKey(curve, rand.Reader)
	if err != nil { log.Fatal(err) }
	alicePubKeyBytes := elliptic.Marshal(curve, aliceX, aliceY)
	fmt.Printf("Alice 공개키 (hex): %s\\n", hex.EncodeToString(alicePubKeyBytes))

	// Bob의 키 쌍 생성
	bobPrivKey, bobX, bobY, err := elliptic.GenerateKey(curve, rand.Reader)
	if err != nil { log.Fatal(err) }
	bobPubKeyBytes := elliptic.Marshal(curve, bobX, bobY)
	fmt.Printf("Bob 공개키 (hex): %s\\n", hex.EncodeToString(bobPubKeyBytes))

	// Alice가 Bob의 공개키로 공유 비밀 계산
	aliceSharedX, _ := curve.ScalarMult(bobX, bobY, alicePrivKey)
	aliceSharedSecret := aliceSharedX.Bytes()
	fmt.Printf("Alice의 공유 비밀 (hex): %s\\n", hex.EncodeToString(aliceSharedSecret))

	// Bob이 Alice의 공개키로 공유 비밀 계산
	bobSharedX, _ := curve.ScalarMult(aliceX, aliceY, bobPrivKey)
	bobSharedSecret := bobSharedX.Bytes()
	fmt.Printf("Bob의 공유 비밀 (hex): %s\\n", hex.EncodeToString(bobSharedSecret))

	if hex.EncodeToString(aliceSharedSecret) == hex.EncodeToString(bobSharedSecret) {
		fmt.Println("\\n공유 비밀 일치!")
	}
}`,
                            typescript: `async function ecdhExample(): Promise<void> {
    // Alice 키 쌍 생성 (P-256 커브)
    const aliceKeyPair = await crypto.subtle.generateKey(
        { name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey", "deriveBits"]
    );
    const alicePubKeyJwk = await crypto.subtle.exportKey("jwk", aliceKeyPair.publicKey);
    console.log("Alice 공개키 (JWK):", JSON.stringify(alicePubKeyJwk).substring(0,60) + "...");


    // Bob 키 쌍 생성
    const bobKeyPair = await crypto.subtle.generateKey(
        { name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey", "deriveBits"]
    );
    const bobPubKeyJwk = await crypto.subtle.exportKey("jwk", bobKeyPair.publicKey);
     console.log("Bob 공개키 (JWK):", JSON.stringify(bobPubKeyJwk).substring(0,60) + "...");


    // Alice가 Bob의 공개키로 공유 비밀 유도
    const aliceSharedSecret = await crypto.subtle.deriveBits(
        { name: "ECDH", public: bobKeyPair.publicKey },
        aliceKeyPair.privateKey,
        256 // 유도할 비트 수
    );
    console.log(\`Alice 공유 비밀 (hex): \${Array.from(new Uint8Array(aliceSharedSecret)).map(b => b.toString(16).padStart(2, '0')).join('')}\`);

    // Bob이 Alice의 공개키로 공유 비밀 유도
    const bobSharedSecret = await crypto.subtle.deriveBits(
        { name: "ECDH", public: aliceKeyPair.publicKey },
        bobKeyPair.privateKey,
        256
    );
    console.log(\`Bob 공유 비밀 (hex): \${Array.from(new Uint8Array(bobSharedSecret)).map(b => b.toString(16).padStart(2, '0')).join('')}\`);
    
    if (Array.from(new Uint8Array(aliceSharedSecret)).toString() === Array.from(new Uint8Array(bobSharedSecret)).toString()) {
        console.log("\\n공유 비밀 일치!");
    }
}
ecdhExample();`
                        }
                    },
                    {
                        name: 'RSA',
                        details: '1977년 개발된 최초의 널리 사용된 공개키 암호 시스템입니다. 매우 큰 두 소수의 곱을 소인수분해하는 것의 어려움에 기반합니다. 암호화/복호화 및 디지털 서명에 모두 사용될 수 있으며, 인터넷 보안의 핵심 기술로 오랫동안 활용되어 왔습니다. 키 길이가 길어야 충분한 보안성을 확보할 수 있다는 단점이 있습니다 (예: 2048비트 이상 권장).',
                        interactive_id: 'rsa-interactive',
                        code_examples: {
                            go: `package main
// Go 표준 라이브러리의 crypto/rsa 패키지는 패딩 방식(OAEP, PSS)을 명시해야 합니다.
// 실제 사용 시에는 적절한 패딩을 사용해야 합니다. 여기서는 개념만 보여줍니다.
// (실제 RSA 암호화/복호화 예제는 패딩 처리로 인해 복잡해짐)
import ("crypto/rand"; "crypto/rsa"; "crypto/sha256"; "encoding/hex"; "fmt"; "log")

func main() {
	// RSA 키 쌍 생성 (2048 비트)
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil { log.Fatal(err) }
	publicKey := &privateKey.PublicKey

	message := []byte("RSA 암호화 테스트 메시지")
	label := []byte("") // OAEP 패딩용 레이블 (선택 사항)
	hash := sha256.New()

	// OAEP 패딩을 사용한 암호화
	ciphertext, err := rsa.EncryptOAEP(hash, rand.Reader, publicKey, message, label)
	if err != nil { log.Fatal(err) }
	fmt.Printf("암호문 (hex): %s\\n", hex.EncodeToString(ciphertext))

	// OAEP 패딩을 사용한 복호화
	plaintext, err := rsa.DecryptOAEP(hash, rand.Reader, privateKey, ciphertext, label)
	if err != nil { log.Fatal(err) }
	fmt.Printf("복호화된 평문: %s\\n", string(plaintext))

	// PSS 패딩을 사용한 서명 생성
    // 실제로는 메시지 자체를 해시한 값을 서명합니다.
    hashed := sha256.Sum256(message)
	signature, err := rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, hashed[:], nil)
	if err != nil { log.Fatal(err) }
	fmt.Printf("서명 (hex): %s\\n", hex.EncodeToString(signature))

	// PSS 패딩을 사용한 서명 검증
	err = rsa.VerifyPSS(publicKey, crypto.SHA256, hashed[:], signature, nil)
	if err != nil {
		fmt.Println("서명 검증 실패:", err)
	} else {
		fmt.Println("서명 검증 성공!")
	}
}`,
                            typescript: `async function rsaOaepExample(plainText: string): Promise<void> {
    // RSA-OAEP 키 쌍 생성
    const keyPair = await crypto.subtle.generateKey(
        {
            name: "RSA-OAEP",
            modulusLength: 2048,
            publicExponent: new Uint8Array([0x01, 0x00, 0x01]), // 65537
            hash: "SHA-256",
        },
        true, // extractable
        ["encrypt", "decrypt"]
    );

    const encodedPlainText = new TextEncoder().encode(plainText);

    // 암호화
    const ciphertext = await crypto.subtle.encrypt(
        { name: "RSA-OAEP" },
        keyPair.publicKey,
        encodedPlainText
    );
    console.log(\`암호문 (hex): \${Array.from(new Uint8Array(ciphertext)).map(b => b.toString(16).padStart(2, '0')).join('')}\`);

    // 복호화
    const decryptedBuffer = await crypto.subtle.decrypt(
        { name: "RSA-OAEP" },
        keyPair.privateKey,
        ciphertext
    );
    console.log(\`복호화된 평문: \${new TextDecoder().decode(decryptedBuffer)}\`);
}
rsaOaepExample("RSA 암호화 테스트 메시지");`
                        }
                    },
                    {
                        name: '타원 곡선 암호 (ECC)',
                        details: '1985년 닐 코블리츠와 빅터 밀러에 의해 제안된 공개키 암호 방식입니다. 유한체 위의 타원 곡선에서 정의된 이산 로그 문제(ECDLP)의 어려움에 기반합니다. RSA에 비해 훨씬 짧은 키 길이로도 동일하거나 더 높은 수준의 보안 강도를 제공하여 효율성이 뛰어납니다. 이로 인해 모바일 기기, IoT 장치 등 자원이 제한된 환경에서 널리 사용됩니다. 주요 응용으로는 ECDH(Elliptic Curve Diffie-Hellman) 키 교환과 ECDSA(Elliptic Curve Digital Signature Algorithm) 디지털 서명이 있습니다.',
                        interactive_id: 'ecc-interactive',
                        code_examples: {
                            go: `package main
// ECDSA 예제 (P-256 커브 사용)
import ("crypto/ecdsa"; "crypto/elliptic"; "crypto/rand"; "crypto/sha256"; "encoding/hex"; "fmt"; "log")

func main() {
	curve := elliptic.P256()
	privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)
	if err != nil { log.Fatal(err) }
	publicKey := &privateKey.PublicKey

	message := []byte("ECDSA 서명 테스트 메시지")
	hashed := sha256.Sum256(message) // 실제로는 메시지 해시값에 서명

	// 서명 생성
	r, s, err := ecdsa.Sign(rand.Reader, privateKey, hashed[:])
	if err != nil { log.Fatal(err) }
	signature := r.Bytes()
	signature = append(signature, s.Bytes()...) // r과 s를 연결하여 서명으로 사용 (간단화)
	fmt.Printf("서명 (hex): %s\\n", hex.EncodeToString(signature))

	// 서명 검증 (r, s 분리 필요 - 실제로는 ASN.1 DER 인코딩된 서명 사용)
    // 여기서는 간단화를 위해 r, s를 직접 사용한다고 가정 (실제 코드와 다름)
    rBytes := signature[:len(signature)/2]
    sBytes := signature[len(signature)/2:]
    var rInt, sInt big.Int
    rInt.SetBytes(rBytes)
    sInt.SetBytes(sBytes)

	isValid := ecdsa.Verify(publicKey, hashed[:], &rInt, &sInt)
	if isValid {
		fmt.Println("서명 검증 성공!")
	} else {
		fmt.Println("서명 검증 실패.")
	}
}`,
                            typescript: `async function ecdsaExample(messageText: string): Promise<void> {
    // ECDSA 키 쌍 생성 (P-256 커브)
    const keyPair = await crypto.subtle.generateKey(
        { name: "ECDSA", namedCurve: "P-256" },
        true, // extractable
        ["sign", "verify"]
    );

    const encodedMessage = new TextEncoder().encode(messageText);

    // 서명 생성
    const signature = await crypto.subtle.sign(
        { name: "ECDSA", hash: { name: "SHA-256" } },
        keyPair.privateKey,
        encodedMessage
    );
    console.log(\`서명 (hex): \${Array.from(new Uint8Array(signature)).map(b => b.toString(16).padStart(2, '0')).join('')}\`);

    // 서명 검증
    const isValid = await crypto.subtle.verify(
        { name: "ECDSA", hash: { name: "SHA-256" } },
        keyPair.publicKey,
        signature,
        encodedMessage
    );
    console.log(\`서명 검증 결과: \${isValid}\`);
}
ecdsaExample("ECDSA 서명 테스트 메시지");`
                        }
                    }
                ]
            },
            aead: {
                title: 'AEAD: 기밀성, 무결성, 인증의 통합적 제공',
                description: '인증된 암호화와 연관 데이터(AEAD)는 데이터의 기밀성, 무결성, 인증 기능을 단일 암호화 과정을 통해 통합적으로 제공하는 현대적인 암호 방식입니다. 암호화되지 않는 추가 데이터(Associated Data)의 무결성 또한 검증할 수 있습니다. 아래 인터랙티브 요소를 통해 AEAD의 처리 흐름을 확인해 보세요.',
                algos: [
                    {
                        name: 'AES-GCM (NIST SP 800-38D)',
                        details: 'AES 블록 암호를 CTR(Counter) 모드로 사용하여 암호화를 수행하고, GMAC을 통해 인증을 제공하는 널리 사용되는 AEAD 모드입니다. GMAC의 핵심인 GHASH는 유한체 GF(2^128) 상의 다항식 연산으로, 병렬 처리가 가능하여 성능이 매우 우수하며, 특히 AES-NI 하드웨어 가속을 통해 높은 처리량을 달성할 수 있습니다. TLS 1.2/1.3 등 주요 보안 프로토콜의 핵심 요소입니다.',
                        interactive_id: 'aes-gcm-interactive',
                        code_examples: {
                            go: `package main
import ( "crypto/aes"; "crypto/cipher"; "crypto/rand"; "encoding/hex"; "fmt"; "io" )

func main() {
	key := []byte("0123456789abcdef0123456789abcdef") 
	plaintext := []byte("AES-GCM 테스트")
	additionalData := []byte("AAD") 
	block, _ := aes.NewCipher(key)
	aesgcm, _ := cipher.NewGCM(block)
	nonce := make([]byte, aesgcm.NonceSize())
	io.ReadFull(rand.Reader, nonce) 

	ciphertext := aesgcm.Seal(nil, nonce, plaintext, additionalData) 
	fmt.Printf("암호문+태그 (hex): %s\\n", hex.EncodeToString(ciphertext))
	// 복호화 로직 생략
}`,
                            typescript: `async function aesGcmExample(plainText: string, aadText: string): Promise<void> {
    const keyBytes = crypto.getRandomValues(new Uint8Array(32)); 
    const nonce = crypto.getRandomValues(new Uint8Array(12));    
    const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
    const encodedPlainText = new TextEncoder().encode(plainText);
    const encodedAad = new TextEncoder().encode(aadText);
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv: nonce, additionalData: encodedAad }, cryptoKey, encodedPlainText);
    console.log(\`암호문+태그 (hex): \${Array.from(new Uint8Array(ciphertext)).map(b => b.toString(16).padStart(2, '0')).join('')}\`);
    // 복호화 로직 생략
}
aesGcmExample("AES-GCM 테스트", "AAD");`
                        }
                    },
                    { 
                        name: 'ChaCha20-Poly1305 (RFC 8439)', 
                        details: '스트림 암호인 ChaCha20과 메시지 인증 코드인 Poly1305를 결합한 AEAD 구성입니다. ChaCha20은 ARX(Add-Rotate-XOR) 연산 기반으로 소프트웨어에서 높은 성능을 보이며, 특히 AES 하드웨어 가속이 없는 모바일 환경 등에서 유리합니다. Poly1305는 일회성 키를 사용하는 고속 MAC입니다. TLS 1.3의 핵심 암호 스위트 중 하나로, 논스(nonce) 재사용 금지가 매우 중요합니다.',
                        interactive_id: 'chacha20poly1305-interactive',
                        code_examples: {
                            go: `package main
import ( "crypto/rand"; "encoding/hex"; "fmt"; "io"; "golang.org/x/crypto/chacha20poly1305" )

func main() {
	key := make([]byte, chacha20poly1305.KeySize)
	io.ReadFull(rand.Reader, key)
	plaintext := []byte("ChaCha20-Poly1305 테스트!")
	additionalData := []byte("부가 데이터")
	aead, _ := chacha20poly1305.New(key)
	nonce := make([]byte, aead.NonceSize())
	io.ReadFull(rand.Reader, nonce) 
	
	ciphertext := aead.Seal(nil, nonce, plaintext, additionalData) 
	fmt.Printf("암호문+태그 (hex): %s\\n", hex.EncodeToString(ciphertext))
	// 복호화 로직 생략
}`,
                            typescript: `// TypeScript에서 ChaCha20-Poly1305는 표준 Web Crypto API에 아직 널리 지원되지 않습니다.
console.warn("TypeScript용 ChaCha20-Poly1305는 표준 Web Crypto API에서 아직 널리 지원되지 않습니다.");`
                        }
                    },
                    { 
                        name: 'XChaCha20-Poly1305', 
                        details: 'ChaCha20-Poly1305의 논스 길이를 96비트에서 192비트로 확장한 버전입니다. 이는 무작위 논스 생성 시 충돌 가능성을 현저히 낮추어, 대규모 분산 시스템이나 상태 관리가 어려운 환경에서 논스 관리를 용이하게 합니다. HChaCha20 함수를 사용하여 192비트 논스로부터 ChaCha20에 사용될 서브키와 단축된 논스를 파생합니다.',
                        interactive_id: 'xchacha20poly1305-interactive',
                        code_examples: {
                            go: `package main
import ( "crypto/rand"; "encoding/hex"; "fmt"; "io"; "golang.org/x/crypto/chacha20poly1305" )
func main() {
	key := make([]byte, chacha20poly1305.KeySize)
	io.ReadFull(rand.Reader, key)
	plaintext := []byte("XChaCha20-Poly1305 테스트!")
	additionalData := []byte("부가 데이터 X")
	aead, _ := chacha20poly1305.NewX(key) 
	nonce := make([]byte, aead.NonceSize()) 
	io.ReadFull(rand.Reader, nonce)
	
	ciphertext := aead.Seal(nil, nonce, plaintext, additionalData)
	fmt.Printf("암호문+태그 (hex): %s\\n", hex.EncodeToString(ciphertext))
	// 복호화 로직 생략
}`,
                            typescript: `// TypeScript에서 XChaCha20-Poly1305는 표준 Web Crypto API에 없습니다.
console.warn("TypeScript용 XChaCha20-Poly1305는 표준 Web Crypto API에 없습니다.");`
                        }
                    },
                ]
            }
        };
        
        let currentAesStep = 0;
        const aesSteps = ['초기 상태', 'SubBytes', 'ShiftRows', 'MixColumns', 'AddRoundKey', '라운드 완료'];

        const chachaAeadSteps = ['입력 (평문, AAD, 키, 논스)', 'ChaCha20 키스트림 생성', '평문 XOR 키스트림 (암호문 생성)', 'Poly1305 인증자 계산 (AAD, 암호문)', '출력 (암호문, 인증 태그)'];
        const aesGcmAeadSteps = ['입력 (평문, AAD, 키, 논스)', 'CTR 모드 암호화', 'GHASH 계산 (AAD, 암호문)', '최종 인증 태그 생성', '출력 (암호문, 인증 태그)'];
        
        const fheSteps = ['사용자: 평문 데이터', '암호화 (FHE 키)', '클라우드: 암호문 연산', '결과 암호문 반환', '사용자: 복호화 (FHE 키)', '연산 결과 확인'];
        let currentFheStep = 0;

        const zkpSteps = ['증명자: 비밀 정보 보유', '증명 생성 (ZKP 프로토콜)', '검증자: 증명 수신', '증명 검증 (정보 노출 없이)', '결과: 참/거짓'];
        let currentZkpStep = 0;

        const dhSteps = ["1. 공개 매개변수 합의 (소수 p, 생성자 g)", "2. Alice: 개인키 a 선택, 공개키 A = g^a mod p 계산", "3. Bob: 개인키 b 선택, 공개키 B = g^b mod p 계산", "4. 공개키 교환 (A, B)", "5. Alice: 공유 비밀 S = B^a mod p 계산", "6. Bob: 공유 비밀 S = A^b mod p 계산", "7. 공유 비밀 S 일치!"];
        let currentDhStep = 0;

        let blake3ChunkCount = 1;

        document.addEventListener('DOMContentLoaded', () => {
            const mainNavButtons = document.querySelectorAll('#main-nav .nav-button');
            const sections = document.querySelectorAll('.main-section');
            const algoTabButtons = document.querySelectorAll('.tab-button');
            const algoContentContainer = document.getElementById('algo-content-container');
            const timelineContainer = document.getElementById('timeline-container');

            function showSection(targetId) {
                sections.forEach(section => {
                    section.classList.toggle('hidden', section.id !== `${targetId}-section`);
                });
                mainNavButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.target === targetId);
                });
                if (targetId === 'future-tech') {
                    initFheFlowInteractive('fhe-flow-interactive');
                    initZkpFlowInteractive('zkp-flow-interactive');
                }
            }
            
            mainNavButtons.forEach(button => {
                button.addEventListener('click', () => {
                    showSection(button.dataset.target);
                });
            });

            function renderAlgoContent(algoType) {
                const data = algoData[algoType];
                let gridColsClass = 'md:grid-cols-1';
                if (data.algos.length === 2) { gridColsClass = 'md:grid-cols-2'; } 
                else if (data.algos.length >= 3) { gridColsClass = 'md:grid-cols-3'; }
                
                let content = `<h3 class="text-2xl font-bold text-center mb-4 text-cyan-800">${data.title}</h3>
                               <p class="text-center text-slate-600 mb-10 max-w-3xl mx-auto">${data.description}</p>
                               <div class="grid ${gridColsClass} gap-6 max-w-7xl mx-auto">`;

                data.algos.forEach(algo => {
                    content += `<div class="content-card p-6 flex flex-col">
                                    <h4 class="font-bold text-xl mb-3 text-cyan-700">${algo.name}</h4>
                                    <p class="text-slate-600 text-sm leading-relaxed flex-grow">${algo.details}</p>
                                    <div id="${algo.interactive_id}" class="interactive-diagram mt-4"></div>`;
                    if (algo.code_examples) {
                        content += `<div class="code-example-container">
                                        <div class="mb-2">
                                            <button class="code-example-toggle" data-lang="go" data-target="code-${algo.interactive_id}-go">Go 예제</button>
                                            <button class="code-example-toggle" data-lang="typescript" data-target="code-${algo.interactive_id}-ts">TypeScript 예제</button>
                                        </div>
                                        <div id="code-${algo.interactive_id}-go" class="code-block hidden"><pre><code class="language-go">${escapeHtml(algo.code_examples.go)}</code></pre></div>
                                        <div id="code-${algo.interactive_id}-ts" class="code-block hidden"><pre><code class="language-typescript">${escapeHtml(algo.code_examples.typescript)}</code></pre></div>
                                    </div>`;
                    }
                    content += `</div>`;
                });
                content += `</div>`;
                algoContentContainer.innerHTML = content;
                
                initInteractiveElements(algoType);
                initCodeExampleToggles();
            }
            
            function escapeHtml(unsafe) {
                if (typeof unsafe !== 'string') return '';
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }

            function initCodeExampleToggles() {
                document.querySelectorAll('.code-example-toggle').forEach(button => {
                    button.addEventListener('click', () => {
                        const lang = button.dataset.lang;
                        const parentCard = button.closest('.content-card');
                        const interactiveDiagramId = parentCard.querySelector('.interactive-diagram').id;
                        const goBlock = parentCard.querySelector(`#code-${interactiveDiagramId}-go`);
                        const tsBlock = parentCard.querySelector(`#code-${interactiveDiagramId}-ts`);

                        if (lang === 'go') {
                            if (goBlock) goBlock.classList.toggle('hidden');
                            if (tsBlock && !tsBlock.classList.contains('hidden')) tsBlock.classList.add('hidden');
                        } else if (lang === 'typescript') {
                            if (tsBlock) tsBlock.classList.toggle('hidden');
                             if (goBlock && !goBlock.classList.contains('hidden')) goBlock.classList.add('hidden');
                        }
                    });
                });
            }

            function initInteractiveElements(algoType) {
                if (algoType === 'hash') {
                    initHashInteractive('sha256-interactive', 'SHA-256', 32);
                    initHashInteractive('blake2-interactive', 'BLAKE2s', 32);
                    initBlake3Interactive('blake3-interactive');
                } else if (algoType === 'symmetric') {
                    initAesRoundsInteractive('aes-rounds-interactive');
                    initAesModesInteractive('aes-modes-interactive');
                } else if (algoType === 'public-key') {
                    initDhInteractive('dh-interactive');
                    initRsaInteractive('rsa-interactive');
                    initEccInteractive('ecc-interactive');
                } else if (algoType === 'aead') {
                    initAeadFlowInteractive('chacha20poly1305-interactive', 'ChaCha20-Poly1305', chachaAeadSteps, 'chacha');
                    initAeadFlowInteractive('aes-gcm-interactive', 'AES-GCM', aesGcmAeadSteps, 'aes-gcm');
                    const xchachaContainer = document.getElementById('xchacha20poly1305-interactive');
                    if(xchachaContainer) xchachaContainer.innerHTML = '<p class="text-sm text-slate-500 p-4 text-center">XChaCha20-Poly1305는 ChaCha20-Poly1305와 유사한 흐름을 가지나, 더 긴 논스를 사용하여 보안성을 강화합니다.<br>(상세 인터랙션은 ChaCha20-Poly1305 참조)</p>';
                }
            }

            function initHashInteractive(containerId, algoName, outputBytes) {
                const container = document.getElementById(containerId);
                if (!container) return;
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">${algoName} 고정 출력 시각화:</p>
                    <label for="${containerId}-input-size" class="text-xs">가상 입력 데이터 크기 (바이트): <span id="${containerId}-input-value">100</span></label>
                    <input type="range" id="${containerId}-input-size" min="1" max="1000" value="100" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                    <p class="text-xs mt-2">입력 (가상): <span id="${containerId}-input-display" class="font-mono bg-white p-1 rounded break-all">데이터... (100 바이트)</span></p>
                    <p class="text-xs mt-1">출력 (${algoName} 해시, ${outputBytes * 8}비트): <span id="${containerId}-output-display" class="font-mono bg-white p-1 rounded break-all">${'...'.repeat(outputBytes)}</span></p>
                    <p class="text-xs text-slate-500 mt-1">입력 크기가 변경되어도 출력 해시의 길이는 항상 ${outputBytes}바이트(${outputBytes*8}비트)로 고정됩니다.</p>
                `;
                const inputSizeSlider = document.getElementById(`${containerId}-input-size`);
                const inputValueDisplay = document.getElementById(`${containerId}-input-value`);
                const inputDisplay = document.getElementById(`${containerId}-input-display`);
                const outputDisplay = document.getElementById(`${containerId}-output-display`);

                inputSizeSlider.addEventListener('input', (e) => {
                    const size = e.target.value;
                    inputValueDisplay.textContent = size;
                    inputDisplay.textContent = `데이터... (${size} 바이트)`;
                    let mockHash = '';
                    for(let i=0; i<outputBytes; i++) {
                        mockHash += Math.floor(Math.random()*256).toString(16).padStart(2,'0').substring(0,1);
                    }
                    outputDisplay.textContent = mockHash.substring(0, outputBytes) + (outputBytes > 16 ? '...' : '');

                });
                let mockInitialHash = '';
                for(let i=0; i<outputBytes; i++) { mockInitialHash += 'X'; }
                outputDisplay.textContent = mockInitialHash;
            }

            function initBlake3Interactive(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                blake3ChunkCount = 1; 

                function renderBlake3Tree() {
                    let treeHtml = '<p class="text-sm font-medium mb-2">BLAKE3 트리 구조 (개념적):</p>';
                    treeHtml += '<div class="flex flex-col items-center">';
                    
                    let currentLevelNodes = [];
                    for(let i=0; i < blake3ChunkCount; i++) {
                        currentLevelNodes.push(`<div class="blake3-node ${i === 0 && blake3ChunkCount > 1 ? '' : (blake3ChunkCount === 1 ? 'active' : '')}">청크 ${i+1}</div>`);
                    }

                    let level = 0;
                    while(currentLevelNodes.length > 1 || level === 0 && currentLevelNodes.length === 1) {
                        treeHtml += `<div class="flex justify-center my-1">${currentLevelNodes.join('')}</div>`;
                        if (currentLevelNodes.length === 1 && level > 0) break;

                        const parentNodes = [];
                        for(let i=0; i < currentLevelNodes.length; i+=2) {
                            if (i + 1 < currentLevelNodes.length) {
                                parentNodes.push(`<div class="blake3-node ${currentLevelNodes.length <= 2 ? 'active' : ''}">부모</div>`);
                            } else {
                                parentNodes.push(currentLevelNodes[i]);
                            }
                        }
                        currentLevelNodes = parentNodes;
                        level++;
                        if (level > 4) break;
                    }
                     if (currentLevelNodes.length === 1 && level > 0) {
                         treeHtml += `<div class="flex justify-center my-1">${currentLevelNodes[0].replace('부모', '루트 해시')}</div>`;
                     }

                    treeHtml += '</div>';
                    treeHtml += `<div class="mt-2 text-center">
                                    <button id="addBlake3Chunk" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">청크 추가</button>
                                    <button id="resetBlake3Tree" class="text-xs bg-slate-500 hover:bg-slate-600 text-white py-1 px-2 rounded">초기화</button>
                                 </div>`;
                    treeHtml += '<p class="text-xs text-slate-500 mt-1 text-center">각 청크는 병렬로 해시된 후, 트리 구조로 병합되어 최종 루트 해시를 생성합니다.</p>';
                    container.innerHTML = treeHtml;

                    document.getElementById('addBlake3Chunk').addEventListener('click', () => {
                        if (blake3ChunkCount < 8) blake3ChunkCount++;
                        renderBlake3Tree();
                    });
                    document.getElementById('resetBlake3Tree').addEventListener('click', () => {
                        blake3ChunkCount = 1;
                        renderBlake3Tree();
                    });
                }
                renderBlake3Tree();
            }

            function initAesRoundsInteractive(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                currentAesStep = 0;
                
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">AES 라운드 과정 (개념적):</p>
                    <div class="flex justify-around items-center mb-2 flex-wrap">
                        ${aesSteps.map((step, index) => `<div id="aes-step-${index}" class="aes-step text-xs">${step}</div>`).join('')}
                    </div>
                    <div id="aes-state-matrix" class="grid grid-cols-4 gap-1 p-2 bg-white border border-slate-300 rounded w-max mx-auto mb-2">
                        ${Array(16).fill(0).map((_, i) => `<div class="data-block" id="aes-byte-${i}">B${i}</div>`).join('')}
                    </div>
                    <div class="text-center">
                        <button id="nextAesStep" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">다음 단계</button>
                        <button id="resetAesSteps" class="text-xs bg-slate-500 hover:bg-slate-600 text-white py-1 px-2 rounded">초기화</button>
                    </div>
                    <p id="aes-step-description" class="text-xs text-slate-500 mt-1 text-center">버튼을 눌러 AES 라운드 단계를 진행하세요.</p>
                `;

                const stepElements = aesSteps.map((_, index) => document.getElementById(`aes-step-${index}`));
                const stateMatrixBytes = Array(16).fill(0).map((_, i) => document.getElementById(`aes-byte-${i}`));
                const descriptionElement = document.getElementById('aes-step-description');

                function updateAesVisual() {
                    stepElements.forEach((el, idx) => el.classList.toggle('active', idx === currentAesStep));
                    stateMatrixBytes.forEach(byteEl => { byteEl.style.backgroundColor = 'white'; byteEl.style.color = '#1e293b';});
                    let desc = "";
                    if (currentAesStep === 0) desc = "초기 상태: 128비트 데이터 블록 (4x4 바이트 행렬)";
                    else if (currentAesStep === 1) { desc = "SubBytes (비선형성): 각 바이트를 S-Box를 이용해 치환하여 혼돈(confusion)을 증가시킵니다."; stateMatrixBytes.forEach(byteEl => { byteEl.style.backgroundColor = '#bae6fd'; byteEl.style.color = '#0c4a6e'; }); }
                    else if (currentAesStep === 2) { desc = "ShiftRows (확산): 각 행의 바이트들을 왼쪽으로 순환 이동시켜 데이터를 확산시킵니다."; for(let r=1; r<4; r++) for(let c=0; c<4; c++) stateMatrixBytes[r*4+c].style.backgroundColor = '#7dd3fc'; }
                    else if (currentAesStep === 3) { desc = "MixColumns (확산): 각 열의 바이트들을 선형 혼합하여 확산을 더욱 강화합니다."; for(let c=0; c<4; c++) for(let r=0; r<4; r++) stateMatrixBytes[r*4+c].style.backgroundColor = '#38bdf8'; }
                    else if (currentAesStep === 4) { desc = "AddRoundKey (키 혼합): 현재 상태와 라운드 키를 XOR 연산합니다."; stateMatrixBytes.forEach(byteEl => { byteEl.style.backgroundColor = '#0ea5e9'; byteEl.style.color = 'white';}); }
                    else if (currentAesStep === 5) desc = "라운드 완료. 이 과정이 키 길이에 따라 10~14회 반복됩니다.";
                    descriptionElement.textContent = desc;
                }

                document.getElementById('nextAesStep').addEventListener('click', () => { currentAesStep = (currentAesStep + 1) % aesSteps.length; updateAesVisual(); });
                document.getElementById('resetAesSteps').addEventListener('click', () => { currentAesStep = 0; updateAesVisual(); });
                updateAesVisual();
            }

            function initAesModesInteractive(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                const renderModeBlocks = (mode) => {
                    let html = '';
                    const patterns = { ecb_plain: [0,0,1,1,0,0,2,2], ecb_cipher: [0,0,1,1,0,0,2,2], cbc_plain: [0,0,1,1,0,0,2,2], cbc_cipher: [3,4,5,6,7,8,9,10] };
                    const colors = ['bg-red-200', 'bg-green-200', 'bg-blue-200', 'bg-yellow-300', 'bg-purple-300', 'bg-pink-300', 'bg-indigo-300', 'bg-teal-300', 'bg-orange-300', 'bg-lime-300', 'bg-cyan-300'];
                    const data = mode === 'ecb' ? patterns.ecb_cipher : patterns.cbc_cipher; const plainData = patterns.ecb_plain;
                    html += '<p class="text-xs mb-1">평문 블록:</p><div class="flex flex-wrap mb-2">';
                    plainData.forEach(p => { html += `<div class="data-block ${colors[p % colors.length]}">P${p}</div>`; });
                    html += '</div>';
                    html += '<p class="text-xs mb-1">암호문 블록:</p><div class="flex flex-wrap">';
                    data.forEach(d => { html += `<div class="data-block ${colors[d % colors.length]}">C${d}</div>`; });
                    html += '</div>'; return html;
                };
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">AES 운영 모드 비교 (ECB vs CBC):</p>
                    <div class="flex justify-center mb-2">
                        <button id="showEcb" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded mr-2">ECB 보기</button>
                        <button id="showCbc" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">CBC 보기</button>
                    </div><div id="aesModeDisplay" class="p-2 bg-white border border-slate-300 rounded">${renderModeBlocks('ecb')}</div>
                    <p id="aesModeDescription" class="text-xs text-slate-500 mt-1 text-center">ECB 모드는 동일 평문 블록이 동일 암호문 블록으로 변환되어 패턴이 노출됩니다.</p>`;
                const displayDiv = document.getElementById('aesModeDisplay'); const descriptionP = document.getElementById('aesModeDescription');
                document.getElementById('showEcb').addEventListener('click', () => { displayDiv.innerHTML = renderModeBlocks('ecb'); descriptionP.textContent = "ECB 모드는 동일 평문 블록이 동일 암호문 블록으로 변환되어 패턴이 노출됩니다."; });
                document.getElementById('showCbc').addEventListener('click', () => { displayDiv.innerHTML = renderModeBlocks('cbc'); descriptionP.textContent = "CBC 모드는 이전 암호문의 영향을 받아 동일 평문 블록이라도 다른 암호문 블록으로 변환되어 패턴이 숨겨집니다."; });
            }

            function initAeadFlowInteractive(containerId, algoName, steps, type) {
                const container = document.getElementById(containerId);
                if (!container) return;
                let currentStep = 0;

                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">${algoName} 처리 흐름 (개념적):</p>
                    <div class="flex flex-col items-center space-y-1 mb-2">
                        ${steps.map((step, index) => `<div id="${type}-step-${index}" class="aead-flow-step text-xs w-full text-center">${step}</div>`).join('<div class="text-2xl self-center text-slate-400">&darr;</div>')}
                    </div>
                     <div class="text-center">
                        <button id="next-${type}-step" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">다음 단계</button>
                        <button id="reset-${type}-steps" class="text-xs bg-slate-500 hover:bg-slate-600 text-white py-1 px-2 rounded">초기화</button>
                    </div>
                    <p id="${type}-step-description" class="text-xs text-slate-500 mt-1 text-center">버튼을 눌러 AEAD 처리 단계를 진행하세요.</p>
                `;
                
                const stepElements = steps.map((_, index) => document.getElementById(`${type}-step-${index}`));
                const descriptionElement = document.getElementById(`${type}-step-description`);

                const descriptions = {
                    'chacha': [
                        "입력: 평문, 부가 인증 데이터(AAD), 암호화 키, 그리고 고유한 논스(Nonce)가 준비됩니다.",
                        "키스트림 생성: ChaCha20을 사용하여 키와 논스로부터 키스트림을 생성합니다.",
                        "암호화: 생성된 키스트림과 평문을 XOR하여 암호문을 만듭니다. (기밀성 확보)",
                        "인증자 계산: Poly1305를 사용하여 AAD와 암호문으로부터 인증 태그를 계산합니다. (무결성 및 인증 확보)",
                        "출력: 최종적으로 암호문과 인증 태그가 생성됩니다. 수신자는 이 두 가지를 모두 검증합니다."
                    ],
                    'aes-gcm': [
                        "입력: 평문, 부가 인증 데이터(AAD), 암호화 키, 그리고 고유한 논스(Nonce/IV)가 준비됩니다.",
                        "CTR 모드 암호화: AES와 카운터(논스 기반)를 이용해 키스트림을 생성하고 평문과 XOR하여 암호문을 생성합니다.",
                        "GHASH 계산: AAD와 암호문을 유한체(Galois Field) 상에서 곱셈(GHASH)하여 중간 인증값을 계산합니다.",
                        "최종 인증 태그 생성: GHASH 결과값을 암호화하여 최종 인증 태그(GMAC)를 생성합니다.",
                        "출력: 암호문과 최종 인증 태그가 함께 생성됩니다. 수신자는 복호화와 태그 검증을 병렬로 수행할 수 있습니다."
                    ]
                };

                function updateVisual(stepVar, stepsArray, descArray, typeStr) {
                    stepElements.forEach((el, idx) => el.classList.toggle('active', idx === stepVar));
                    descriptionElement.textContent = descArray[typeStr][stepVar];
                }
                
                let stepVariables = {'chacha': 0, 'aes-gcm': 0}; // Initialize step variables

                document.getElementById(`next-${type}-step`).addEventListener('click', () => { 
                    stepVariables[type] = (stepVariables[type] + 1) % steps.length; 
                    updateVisual(stepVariables[type], steps, descriptions, type);
                });
                document.getElementById(`reset-${type}-steps`).addEventListener('click', () => { 
                    stepVariables[type] = 0; 
                    updateVisual(stepVariables[type], steps, descriptions, type);
                });
                updateVisual(stepVariables[type], steps, descriptions, type);
            }
            
            function initDhInteractive(containerId) {
                const container = document.getElementById(containerId);
                if(!container) return;
                currentDhStep = 0;
                 container.innerHTML = `
                    <p class="text-sm font-medium mb-2">디피-헬만 키 교환 과정 (개념적):</p>
                    <div class="flex flex-col items-center space-y-1 mb-2">
                        ${dhSteps.map((step, index) => `<div id="dh-step-${index}" class="pkc-step text-xs w-full text-center">${step}</div>`).join('<div class="text-2xl self-center text-slate-400">&darr;</div>')}
                    </div>
                     <div class="text-center">
                        <button id="next-dh-step" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">다음 단계</button>
                        <button id="reset-dh-steps" class="text-xs bg-slate-500 hover:bg-slate-600 text-white py-1 px-2 rounded">초기화</button>
                    </div>
                `;
                const stepElements = dhSteps.map((_,index) => document.getElementById(`dh-step-${index}`));
                function updateDhVisual() {
                    stepElements.forEach((el,idx) => el.classList.toggle('active', idx === currentDhStep));
                }
                document.getElementById('next-dh-step').addEventListener('click', () => { currentDhStep = (currentDhStep + 1) % dhSteps.length; updateDhVisual(); });
                document.getElementById('reset-dh-steps').addEventListener('click', () => { currentDhStep = 0; updateDhVisual(); });
                updateDhVisual();
            }

            function initRsaInteractive(containerId) {
                const container = document.getElementById(containerId);
                if(!container) return;
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">RSA 암호화/서명 (개념적):</p>
                    <div class="grid grid-cols-2 gap-4 text-xs">
                        <div class="border p-2 rounded bg-white">
                            <p class="font-semibold text-cyan-700">암호화 (Encryption)</p>
                            <ol class="list-decimal list-inside mt-1 space-y-1">
                                <li>수신자: 공개키 (N, e) 생성 및 배포</li>
                                <li>송신자: 평문 M을 C = M^e mod N 으로 암호화</li>
                                <li>수신자: 암호문 C를 M = C^d mod N 으로 복호화 (d는 개인키)</li>
                            </ol>
                        </div>
                        <div class="border p-2 rounded bg-white">
                            <p class="font-semibold text-cyan-700">디지털 서명 (Digital Signature)</p>
                            <ol class="list-decimal list-inside mt-1 space-y-1">
                                <li>송신자: 메시지 해시 H(M) 계산</li>
                                <li>송신자: 서명 S = H(M)^d mod N 생성 (개인키 d 사용)</li>
                                <li>수신자: H(M)과 H(M)' = S^e mod N 비교하여 검증</li>
                            </ol>
                        </div>
                    </div>
                    <p class="text-xs text-slate-500 mt-2 text-center">실제로는 OAEP, PSS 등의 패딩 방식이 사용되어 보안성을 강화합니다.</p>
                `;
            }

            function initEccInteractive(containerId) {
                const container = document.getElementById(containerId);
                if(!container) return;
                // 매우 단순화된 타원 곡선과 점 덧셈 시각화 (개념적)
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">타원 곡선 연산 (개념적):</p>
                    <div class="relative w-full h-32 bg-slate-200 rounded overflow-hidden">
                        <div class="absolute w-full h-full" style="clip-path: ellipse(45% 35% at 50% 50%); background-color: #a5f3fc;"></div>
                        <div id="ecc-point-g" class="ecc-point" style="left: 20%; top: 45%;">G</div>
                        <div id="ecc-point-p" class="ecc-point" style="left: 40%; top: 65%;">P</div>
                        <div id="ecc-point-q" class="ecc-point hidden" style="left: 70%; top: 30%;">Q</div>
                        <svg id="ecc-line" class="absolute w-full h-full" style="display:none;">
                           <line x1="22%" y1="50%" x2="42%" y2="70%" stroke="#0891b2" stroke-width="2"/>
                           <line id="ecc-line-reflected" x1="42%" y1="70%" x2="72%" y2="35%" stroke="#0891b2" stroke-width="1" stroke-dasharray="4"/>
                        </svg>
                    </div>
                    <p class="text-xs text-slate-500 mt-2 text-center">
                        ECC는 타원 곡선 위의 점들 간의 연산(예: 점 덧셈 P+G=Q)을 기반으로 합니다. 
                        스칼라 곱셈 (kP = P+P+...+P, k번)의 역연산(주어진 P, Q에 대해 k 찾기)이 어려운 점(ECDLP)을 이용합니다.
                        <button id="ecc-add-points" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-0.5 px-1 rounded mt-1">점 덧셈 시연</button>
                    </p>
                `;
                const qPoint = document.getElementById('ecc-point-q');
                const line = document.getElementById('ecc-line');
                document.getElementById('ecc-add-points').addEventListener('click', () => {
                    qPoint.classList.remove('hidden');
                    line.style.display = 'block';
                    setTimeout(() => {
                         qPoint.classList.add('hidden');
                         line.style.display = 'none';
                    }, 2000);
                });
            }


            function initFheFlowInteractive(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                currentFheStep = 0;
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">FHE 기본 흐름 (개념적):</p>
                    <div class="flex flex-col items-center space-y-1 mb-2">
                        ${fheSteps.map((step, index) => `<div id="fhe-step-${index}" class="future-tech-step text-xs w-full text-center">${step}</div>`).join('<div class="text-2xl self-center text-slate-400">&darr;</div>')}
                    </div>
                     <div class="text-center">
                        <button id="next-fhe-step" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">다음 단계</button>
                        <button id="reset-fhe-steps" class="text-xs bg-slate-500 hover:bg-slate-600 text-white py-1 px-2 rounded">초기화</button>
                    </div>
                `;
                const stepElements = fheSteps.map((_,index) => document.getElementById(`fhe-step-${index}`));
                function updateFheVisual() {
                    stepElements.forEach((el,idx) => el.classList.toggle('active', idx === currentFheStep));
                }
                document.getElementById('next-fhe-step').addEventListener('click', () => { currentFheStep = (currentFheStep + 1) % fheSteps.length; updateFheVisual(); });
                document.getElementById('reset-fhe-steps').addEventListener('click', () => { currentFheStep = 0; updateFheVisual(); });
                updateFheVisual();
            }

            function initZkpFlowInteractive(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                currentZkpStep = 0;
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">ZKP 기본 상호작용 (개념적):</p>
                    <div class="flex flex-col items-center space-y-1 mb-2">
                        ${zkpSteps.map((step, index) => `<div id="zkp-step-${index}" class="future-tech-step text-xs w-full text-center">${step}</div>`).join('<div class="text-2xl self-center text-slate-400">&rlarr;</div>')}
                    </div>
                     <div class="text-center">
                        <button id="next-zkp-step" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">다음 단계</button>
                        <button id="reset-zkp-steps" class="text-xs bg-slate-500 hover:bg-slate-600 text-white py-1 px-2 rounded">초기화</button>
                    </div>
                `;
                 const stepElements = zkpSteps.map((_,index) => document.getElementById(`zkp-step-${index}`));
                function updateZkpVisual() {
                    stepElements.forEach((el,idx) => el.classList.toggle('active', idx === currentZkpStep));
                }
                document.getElementById('next-zkp-step').addEventListener('click', () => { currentZkpStep = (currentZkpStep + 1) % zkpSteps.length; updateZkpVisual(); });
                document.getElementById('reset-zkp-steps').addEventListener('click', () => { currentZkpStep = 0; updateZkpVisual(); });
                updateZkpVisual();
            }


            algoTabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    algoTabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    renderAlgoContent(button.dataset.algoTarget);
                });
            });
            
            function renderTimeline() {
                let html = '';
                timelineData.forEach(item => {
                    html += `<div class="timeline-item">
                                <div class="timeline-dot"></div>
                                <time class="mb-1 text-sm font-normal leading-none text-slate-500">${item.year}</time>
                                <h3 class="text-lg font-semibold text-cyan-800">${item.title}</h3>
                                <p class="text-base font-normal text-slate-600 leading-relaxed">${item.description}</p>
                             </div>`;
                });
                timelineContainer.innerHTML = html;
            }

            renderTimeline();
            renderAlgoContent('hash'); 

            const securityCtx = document.getElementById('securityChart').getContext('2d');
            new Chart(securityCtx, {
                type: 'bar',
                data: {
                    labels: ['AES-128', 'AES-256', 'SHA-256', 'SHA-512', 'ML-KEM-512 (NIST L1)', 'ML-DSA-44 (NIST L2)'],
                    datasets: [{
                        label: '고전적 등가 보안 강도 (비트)',
                        data: [128, 256, 128, 256, 128, 128], 
                        backgroundColor: '#06b6d4',
                        borderColor: '#0891b2',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    label += `${context.raw} 비트`;
                                    if (context.label.includes('ML-KEM')) label += ' (vs AES-128)';
                                    if (context.label.includes('ML-DSA')) label += ' (vs SHA-256)';
                                    return label;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: '알고리즘별 고전적 보안 강도 (NIST 기준 등가)'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: '보안 비트 수' }
                        }
                    }
                }
            });

            const speedCtx = document.getElementById('speedChart').getContext('2d');
            new Chart(speedCtx, {
                type: 'bar',
                data: {
                    labels: ['SHA-256', 'SHA-512', 'BLAKE2s', 'BLAKE3 (single-thread)', 'AES-256-GCM (NI)', 'ChaCha20-Poly1305'],
                    datasets: [{
                        label: '상대적 연산 속도 (높을수록 우수)',
                        data: [60, 40, 80, 100, 90, 85], 
                        backgroundColor: ['#67e8f9', '#22d3ee', '#06b6d4', '#0891b2', '#0e7490', '#164e63'],
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.x !== null) {
                                        label += `${context.parsed.x} (상대값)`;
                                    }
                                    return label;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: '소프트웨어 구현 기반 상대적 성능 (일반 CPU 환경 기준)'
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: { display: true, text: '성능 지표 (상대값)' }
                        }
                    }
                }
            });
        });
    </script>
</body>
</html>
