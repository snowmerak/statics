<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>대화형 암호화 알고리즘 탐색기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Visualization & Content Choices: 
        1. History -> Goal: Show evolution -> Viz: Vertical Timeline (HTML/CSS) -> Interaction: Scroll-based reveal -> Justification: Provides chronological context intuitively.
        2. Algorithm Comparison -> Goal: Compare key metrics -> Viz: Bar Charts (Chart.js), Static Table (HTML) -> Interaction: Dropdown for charts, static view for table -> Justification: Makes quantitative comparisons immediate and clear across multiple dimensions (speed, security, size).
        3. AES Rounds/Modes -> Goal: Explain block processing differences -> Viz: Interactive step-by-step diagram (HTML/CSS/JS) & ECB/CBC comparison -> Interaction: Click buttons to advance steps/switch views -> Justification: Visually demonstrates abstract concepts for better understanding.
        4. Hash Function Properties -> Goal: Illustrate fixed output/tree structure -> Viz: Interactive input/output demo & conceptual tree diagram (HTML/CSS/JS) -> Interaction: Slider/button clicks -> Justification: Makes abstract properties tangible.
        5. AEAD Flow -> Goal: Show integrated encryption/authentication -> Viz: Interactive flow diagram (HTML/CSS/JS) -> Interaction: Click to highlight stages -> Justification: Clarifies multi-step process.
        6. PQC Concepts -> Goal: Inform about quantum threat & solutions -> Viz: Info Cards & Flow Diagram (HTML/CSS) with enhanced academic text including detailed NIST Security Levels explanation -> Interaction: Hover for details -> Justification: Breaks down a complex new topic into smaller, manageable chunks with deeper context.
        Library/Method: All visualizations are built with Chart.js (Canvas) or structured HTML/CSS with Tailwind and Vanilla JS, adhering to the NO SVG/Mermaid constraint. The chosen methods support the application's goal of interactive learning and clear information presentation. -->
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-800 */
        }
        .section-title {
            color: #0891b2; /* cyan-600 */
        }
        .nav-button {
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
        }
        .nav-button.active {
            border-bottom-color: #0891b2; /* cyan-600 */
            color: #0e7490; /* cyan-700 */
            font-weight: 600;
        }
        .content-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: transform 0.2s ease-in-out;
        }
        .content-card:hover {
            transform: translateY(-5px);
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 40vh;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .timeline-item {
            position: relative;
            padding-bottom: 2rem;
            padding-left: 2rem;
            border-left: 2px solid #cbd5e1; /* slate-300 */
        }
        .timeline-item:last-child {
            border-left: 2px solid transparent;
        }
        .timeline-dot {
            position: absolute;
            left: -0.5rem;
            top: 0.25rem;
            height: 1rem;
            width: 1rem;
            border-radius: 9999px;
            background-color: white;
            border: 3px solid #0891b2; /* cyan-600 */
        }
        .tab-button.active {
            background-color: #0891b2; /* cyan-600 */
            color: white;
        }
        .interactive-diagram {
            border: 1px solid #e2e8f0; /* slate-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: #f1f5f9; /* slate-100 */
            min-height: 200px;
        }
        .aes-step, .aead-flow-step, .blake3-node {
            padding: 0.5rem;
            margin: 0.25rem;
            border: 1px solid #94a3b8; /* slate-400 */
            border-radius: 0.25rem;
            background-color: white;
            transition: background-color 0.3s, transform 0.3s;
        }
        .aes-step.active, .aead-flow-step.active, .blake3-node.active {
            background-color: #06b6d4; /* cyan-500 */
            color: white;
            transform: scale(1.05);
        }
        .data-block {
            display: inline-block;
            width: 40px; height: 40px;
            line-height: 40px; text-align: center;
            border: 1px solid #64748b; /* slate-500 */
            margin: 2px; font-size: 0.8rem;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #0891b2;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #334155;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.875rem;
            line-height: 1.25rem;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="antialiased">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold section-title mb-2">대화형 암호화 알고리즘 탐색기</h1>
            <p class="text-lg text-slate-600">암호학의 역사적 발전 과정부터 현대 주요 알고리즘의 심층 분석, 그리고 양자내성암호의 미래 전망까지 체계적으로 조망합니다.</p>
        </header>

        <nav id="main-nav" class="flex justify-center space-x-4 md:space-x-8 mb-12 border-b border-slate-200">
            <button class="nav-button active" data-target="timeline">암호학의 발전사</button>
            <button class="nav-button" data-target="modern-algos">현대 핵심 알고리즘</button>
            <button class="nav-button" data-target="pqc">양자내성암호 동향</button>
            <button class="nav-button" data-target="comparison">알고리즘 비교 분석</button>
        </nav>

        <main>
            <section id="timeline-section" class="main-section">
                <div class="max-w-4xl mx-auto">
                    <h2 class="text-3xl font-bold text-center mb-8 section-title">암호학의 발전사: 주요 이정표</h2>
                    <p class="text-center text-slate-600 mb-12">정보 보호를 위한 인류의 지적 여정은 고대 암호 체계에서 시작하여, 수학적 이론과 컴퓨팅 기술의 발전에 힘입어 현대의 정교한 암호 시스템으로 진화해왔습니다. 본 연대기는 암호학의 주요 변곡점과 핵심적인 기술 발전을 조명하며, 현재와 미래 암호 기술의 토대를 이해하는 데 도움을 줄 것입니다.</p>
                    <div id="timeline-container"></div>
                </div>
            </section>

            <section id="modern-algos-section" class="main-section hidden">
                <h2 class="text-3xl font-bold text-center mb-8 section-title">현대 핵심 암호 알고리즘 심층 분석</h2>
                <p class="text-center text-slate-600 mb-12">현대 디지털 정보 시스템의 보안은 다양한 암호학적 프리미티브에 의존합니다. 본 섹션에서는 데이터 무결성을 위한 해시 함수, 기밀성 보장을 위한 대칭키 암호, 그리고 기밀성, 무결성, 인증을 통합 제공하는 AEAD(Authenticated Encryption with Associated Data) 구성의 주요 알고리즘들을 심층적으로 분석합니다. 각 탭을 통해 이들의 작동 원리, 보안 특성, 주요 응용 분야 및 인터랙티브 시각화를 살펴보십시오.</p>
                <div class="flex justify-center mb-8 border border-slate-200 rounded-lg p-1 max-w-md mx-auto bg-slate-100">
                    <button class="tab-button flex-1 p-2 rounded-md transition-colors duration-300 active" data-algo-target="hash">해시 함수</button>
                    <button class="tab-button flex-1 p-2 rounded-md transition-colors duration-300" data-algo-target="symmetric">대칭키 암호</button>
                    <button class="tab-button flex-1 p-2 rounded-md transition-colors duration-300" data-algo-target="aead">AEAD</button>
                </div>
                <div id="algo-content-container"></div>
            </section>

            <section id="pqc-section" class="main-section hidden">
                <h2 class="text-3xl font-bold text-center mb-8 section-title">미래 암호 패러다임: 양자내성암호(PQC) 동향</h2>
                <p class="text-center text-slate-600 mb-12">대규모 양자컴퓨터의 출현은 현재 널리 사용되는 공개키 암호 체계(RSA, ECC 등)의 기반이 되는 수학적 문제(소인수분해, 이산 로그)를 효율적으로 해결할 수 있어, 디지털 인프라 전반에 심각한 보안 위협을 야기합니다. 이에 대응하기 위해, 양자컴퓨터로도 해독하기 어려운 새로운 암호학적 기반을 갖춘 양자내성암호(PQC)의 연구 및 표준화가 미국 NIST 주도로 활발히 진행되고 있습니다. 본 섹션에서는 PQC의 필요성과 주요 표준화 동향을 소개합니다.</p>
                <div class="grid md:grid-cols-2 gap-8 items-start">
                    <div class="content-card p-6">
                        <h3 class="text-xl font-bold text-cyan-700 mb-3">양자 컴퓨팅의 암호학적 위협</h3>
                        <p class="text-slate-600 mb-4">1994년 피터 쇼어(Peter Shor)가 제안한 쇼어 알고리즘은 현재 공개키 암호 시스템의 근간인 소인수분해 및 이산 로그 문제의 주기성(periodicity)을 효율적으로 찾아 해결할 수 있음을 이론적으로 증명했습니다. 이는 RSA, ECC 등 핵심 공개키 암호의 보안성을 근본적으로 위협합니다.</p>
                        <div class="p-4 bg-yellow-50 border border-yellow-200 rounded-lg mb-4">
                           <h4 class="font-semibold text-yellow-800">PQC의 양자 내성 근거</h4>
                           <p class="text-yellow-700 text-sm">PQC 알고리즘은 대부분 <span class="tooltip">격자(Lattice) 기반 문제<span class="tooltiptext">다차원 공간에 규칙적으로 배열된 점들의 집합인 격자에서, 특정 벡터(Shortest Vector Problem)나 가까운 벡터(Closest Vector Problem)를 찾는 문제.</span></span>의 어려움에 기반합니다. 이러한 문제들은 쇼어 알고리즘이 공략하는 주기성 구조를 가지고 있지 않아, 현재까지 알려진 양자 알고리즘으로는 효율적인 해법이 존재하지 않습니다. 이것이 PQC의 양자 내성 핵심 근거입니다.</p>
                        </div>
                        <div class="p-4 bg-red-50 border border-red-200 rounded-lg">
                            <h4 class="font-semibold text-red-800">"지금 수집하고, 나중에 해독" (Harvest Now, Decrypt Later) 시나리오</h4>
                            <p class="text-red-700 text-sm">공격자가 현재 암호화된 데이터를 대량으로 수집·저장한 후, 미래에 강력한 양자컴퓨터를 이용하여 이를 해독하는 전략입니다. 국가 기밀, 금융 정보, 개인 식별 정보 등 장기적인 기밀 유지가 필수적인 데이터에 대해 중대한 위협으로 간주됩니다.</p>
                        </div>
                    </div>
                    <div class="content-card p-6">
                        <h3 class="text-xl font-bold text-cyan-700 mb-3">NIST PQC 표준화 동향</h3>
                        <p class="text-slate-600 mb-2">미국 국립표준기술연구소(NIST)는 PQC 표준화 과정을 통해 다음과 같은 알고리즘들을 1차 표준으로 선정했습니다 (2024년 8월 FIPS 발표 기준):</p>
                        <ul class="space-y-2 mb-4">
                            <li class="p-2 bg-cyan-50 rounded-md text-sm"><strong>ML-KEM (FIPS 203):</strong> CRYSTALS-KYBER 기반 키 캡슐화 메커니즘.</li>
                            <li class="p-2 bg-cyan-50 rounded-md text-sm"><strong>ML-DSA (FIPS 204):</strong> CRYSTALS-Dilithium 기반 디지털 서명.</li>
                            <li class="p-2 bg-cyan-50 rounded-md text-sm"><strong>SLH-DSA (FIPS 205):</strong> SPHINCS+ 기반 상태 비저장 해시 기반 디지털 서명.</li>
                        </ul>
                        <hr class="my-4 border-slate-200">
                        <h4 class="font-semibold text-cyan-800 mb-2">NIST 보안 레벨 (Security Levels) 이해하기</h4>
                        <p class="text-slate-600 text-sm mb-2">NIST는 PQC 알고리즘의 보안 강도를 평가하고 비교하기 위해 5가지 보안 레벨을 정의했습니다. 이 레벨들은 기존의 잘 알려진 암호(AES, SHA)를 공격하는 데 필요한 계산 자원과 PQC 알고리즘을 공격하는 데 필요한 자원을 비교하여 설정됩니다. 이는 사용자가 특정 응용 환경의 보안 요구사항에 맞는 PQC 알고리즘을 선택하는 데 중요한 기준을 제공합니다.</p>
                        <ul class="space-y-1 text-sm list-disc list-inside text-slate-600">
                            <li><strong>레벨 1:</strong> <span class="tooltip">AES-128<span class="tooltiptext">128비트 키를 사용하는 AES. 이 수준의 공격은 단기적으로 가장 먼저 현실화될 수 있는 양자 위협으로 간주됩니다.</span></span>을 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                            <li><strong>레벨 2:</strong> <span class="tooltip">SHA-256/SHA3-256<span class="tooltiptext">256비트 해시 함수의 충돌 저항성. 또는 AES-192와 유사한 작업량으로 간주되기도 합니다.</span></span>을 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                            <li><strong>레벨 3:</strong> <span class="tooltip">AES-192<span class="tooltiptext">192비트 키를 사용하는 AES. 레벨 1보다 높은 보안성을 제공합니다.</span></span>를 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                            <li><strong>레벨 4:</strong> <span class="tooltip">SHA-384/SHA3-384<span class="tooltiptext">384비트 해시 함수의 충돌 저항성. 또는 AES-256과 유사한 작업량으로 간주되기도 합니다.</span></span>을 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                            <li><strong>레벨 5:</strong> <span class="tooltip">AES-256<span class="tooltiptext">256비트 키를 사용하는 AES. 현재 고전 컴퓨팅 환경에서 매우 강력한 보안 수준입니다.</span></span>을 목표로 하는 공격에 대한 보안 강도와 동등.</li>
                        </ul>
                        <p class="text-xs text-slate-500 mt-2">PQC 알고리즘은 기존 공개키 암호와 다른 수학적 문제에 기반하므로, 이러한 보안 레벨은 다양한 PQC 후보들을 일관된 기준으로 평가하고, 실제 시스템에 적용 시 필요한 보안 요구사항을 충족하는지 판단하는 데 중요합니다. 예를 들어, ML-KEM-512는 레벨 1, ML-KEM-768은 레벨 3, ML-KEM-1024는 레벨 5에 해당합니다.</p>
                    </div>
                </div>
            </section>

            <section id="comparison-section" class="main-section hidden">
                <h2 class="text-3xl font-bold text-center mb-8 section-title">주요 암호 알고리즘 비교 분석</h2>
                <p class="text-center text-slate-600 mb-12">암호 알고리즘 선택 시 보안 강도, 연산 속도, 키 및 서명 크기 등 다양한 요소를 고려해야 합니다. 아래 자료들은 주요 현대 암호 알고리즘들의 핵심 특성을 비교하여 보여줍니다. 이를 통해 특정 응용 환경 및 보안 요구사항에 적합한 알고리즘을 선택하는 데 참고할 수 있습니다.</p>
                <div class="grid md:grid-cols-2 gap-8 mb-8">
                    <div class="content-card p-6">
                        <h3 class="text-xl font-bold text-center mb-4 text-cyan-700">고전적 보안 강도 (등가 비트 수)</h3>
                        <div class="chart-container">
                            <canvas id="securityChart"></canvas>
                        </div>
                        <p class="text-xs text-slate-500 mt-2 text-center">해시 함수의 경우 충돌 저항성 기준, 대칭키는 키 길이 기준입니다. PQC 알고리즘은 NIST 보안 레벨에 따른 등가 강도를 나타냅니다.</p>
                    </div>
                    <div class="content-card p-6">
                        <h3 class="text-xl font-bold text-center mb-4 text-cyan-700">상대적 연산 속도</h3>
                        <div class="chart-container">
                            <canvas id="speedChart"></canvas>
                        </div>
                        <p class="text-xs text-slate-500 mt-2 text-center">AES-GCM은 전용 하드웨어 가속(AES-NI) 시, ChaCha20-Poly1305는 소프트웨어 구현 시 뛰어난 성능을 보입니다. BLAKE3는 병렬 처리 능력에서 강점을 가집니다.</p>
                    </div>
                </div>
                <div class="content-card p-6 max-w-4xl mx-auto">
                    <h3 class="text-xl font-bold text-center mb-4 text-cyan-700">주요 매개변수 크기 비교 (바이트)</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm text-left text-slate-600">
                            <thead class="text-xs text-slate-700 uppercase bg-slate-100">
                                <tr>
                                    <th scope="col" class="px-6 py-3">알고리즘</th>
                                    <th scope="col" class="px-6 py-3">분류</th>
                                    <th scope="col" class="px-6 py-3">키 크기 (Public/Private)</th>
                                    <th scope="col" class="px-6 py-3">출력/서명/태그 크기</th>
                                    <th scope="col" class="px-6 py-3">IV/논스 크기</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="bg-white border-b">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">AES-256-GCM</th>
                                    <td class="px-6 py-4">AEAD</td>
                                    <td class="px-6 py-4">32 (비밀키)</td>
                                    <td class="px-6 py-4">16 (인증 태그)</td>
                                    <td class="px-6 py-4">12 (권장)</td>
                                </tr>
                                <tr class="bg-slate-50 border-b">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">ChaCha20-Poly1305</th>
                                    <td class="px-6 py-4">AEAD</td>
                                    <td class="px-6 py-4">32 (비밀키)</td>
                                    <td class="px-6 py-4">16 (인증 태그)</td>
                                    <td class="px-6 py-4">12</td>
                                </tr>
                                 <tr class="bg-white border-b">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">SHA-256</th>
                                    <td class="px-6 py-4">해시</td>
                                    <td class="px-6 py-4">-</td>
                                    <td class="px-6 py-4">32 (해시)</td>
                                    <td class="px-6 py-4">-</td>
                                </tr>
                                <tr class="bg-slate-50 border-b">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">ML-KEM-512 (NIST L1)</th>
                                    <td class="px-6 py-4">PQC KEM</td>
                                    <td class="px-6 py-4">800 / 1632</td>
                                    <td class="px-6 py-4">768 (암호문)</td>
                                    <td class="px-6 py-4">-</td>
                                </tr>
                                <tr class="bg-white">
                                    <th scope="row" class="px-6 py-4 font-medium text-slate-900 whitespace-nowrap">ML-DSA-44 (NIST L2)</th>
                                    <td class="px-6 py-4">PQC 서명</td>
                                    <td class="px-6 py-4">1312 / 2528</td>
                                    <td class="px-6 py-4">2420 (서명)</td>
                                    <td class="px-6 py-4">-</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        const timelineData = [
            { year: "기원전 400년경", title: "스키테일 암호", description: "고대 스파르타에서 사용된 전치 암호의 초기 형태로, 막대의 지름이 암호화 키 역할을 수행했습니다. 군사 통신의 기밀성 유지 목적이었습니다." },
            { year: "기원전 100-44년", title: "카이사르 암호", description: "율리우스 카이사르가 사용한 단일 문자 치환 암호로, 알파벳을 일정한 간격으로 이동시켜 암호화했습니다. 단순성으로 인해 빈도 분석에 취약했습니다." },
            { year: "16세기", title: "비즈네르 암호", description: "다중 문자 치환 암호로, 키워드를 사용하여 여러 카이사르 암호를 조합하는 방식입니다. 단일 문자 빈도 분석을 효과적으로 방어했으나, 키 길이 및 반복성에 약점이 있었습니다." },
            { year: "1940년대", title: "에니그마 기계 해독", description: "앨런 튜링을 비롯한 블레츨리 파크 연구팀이 독일군의 에니그마 암호를 해독, 제2차 세계대전의 전황에 결정적 영향을 미쳤습니다. 이는 암호 해독학의 중요성을 부각시킨 사건입니다." },
            { year: "1976년", title: "디피-헬만 키 교환", description: "최초의 실용적인 공개키 기반 키 교환 프로토콜로, 안전하지 않은 통신 채널 상에서 비밀키를 공유할 수 있는 방법을 제시하여 현대 암호학의 혁명적 전환을 이끌었습니다." },
            { year: "1977년", title: "DES (데이터 암호 표준) 발표", description: "미국 정부 표준으로 채택된 대칭키 블록 암호로, 56비트 키를 사용했습니다. 금융 거래 등 광범위한 분야에서 사용되었으나, 키 길이의 한계로 이후 AES로 대체되었습니다." },
            { year: "1977년", title: "RSA 알고리즘 개발", description: "리베스트, 샤미르, 애들먼이 개발한 최초의 실용적인 공개키 암호 시스템으로, 큰 수의 소인수분해 어려움에 기반합니다. 암호화 및 디지털 서명에 널리 활용됩니다." },
            { year: "1991년", title: "PGP (Pretty Good Privacy) 공개", description: "필 짐머만이 개발한 이메일 암호화 프로그램으로, 강력한 암호 기술의 대중화에 기여했습니다. 암호 기술 수출 통제 논쟁을 촉발하기도 했습니다." },
            { year: "1994년", title: "쇼어 알고리즘 발표", description: "피터 쇼어가 제안한 양자 알고리즘으로, 대규모 양자컴퓨터가 RSA, ECC 등 기존 공개키 암호를 효율적으로 해독할 수 있음을 이론적으로 증명하여 PQC 연구의 필요성을 제기했습니다." },
            { year: "1995년", title: "SHA-1 발표", description: "NIST가 발표한 160비트 출력의 해시 함수로 널리 사용되었으나, 2005년 이후 이론적 충돌 공격 가능성이 제기되고 2017년 실제 충돌이 시연되어 현재는 보안상 취약한 것으로 간주됩니다." },
            { year: "2001년", title: "AES (고급 암호 표준) 선정", description: "NIST의 공개 공모를 통해 라인달(Rijndael) 알고리즘이 DES를 대체할 차세대 대칭키 암호 표준으로 선정되었습니다. 128, 192, 256비트 키를 지원하며 현재 표준으로 사용됩니다." },
            { year: "2015년", title: "SHA-3 표준 발표", description: "NIST가 새로운 해시 함수 표준으로 Keccak 알고리즘을 선정했습니다. SHA-2와 내부 구조(스펀지 구조)가 달라 알고리즘 다양성을 확보했습니다." },
            { year: "2018년", title: "TLS 1.3 발표", description: "IETF가 발표한 최신 전송 계층 보안 프로토콜로, 보안성과 성능을 대폭 향상시켰습니다. 구형 암호 스위트를 제거하고 완전 순방향 비밀성(PFS)을 강화했습니다." },
            { year: "2024년 8월", title: "NIST PQC 1차 표준 발표 (FIPS)", description: "NIST가 양자컴퓨터 위협에 대응하기 위한 1차 양자내성암호 표준으로 ML-KEM (Kyber), ML-DSA (Dilithium), SLH-DSA (SPHINCS+)를 FIPS로 공식 발표했습니다." },
        ];

        const algoData = {
            hash: {
                title: '해시 함수: 데이터 무결성의 수호자',
                description: '암호학적 해시 함수는 임의 길이의 입력 데이터를 고정된 길이의 해시값(또는 메시지 다이제스트)으로 변환하는 단방향 함수입니다. 주요 보안 속성으로는 역상 저항성, 제2 역상 저항성, 충돌 저항성이 요구됩니다. 디지털 서명, 데이터 무결성 검증, 패스워드 저장 등 다양한 보안 응용의 핵심 구성 요소입니다. 아래 인터랙티브 요소를 통해 해시 함수의 특성을 살펴보세요.',
                algos: [
                    { 
                        name: 'SHA-256 (FIPS 180-4)', 
                        details: '256비트 해시값을 생성하는 SHA-2 계열의 대표적인 알고리즘입니다. Merkle-Damgård 구조를 기반으로 하며, 이 반복 구조는 길이 확장 공격에 취약할 수 있어 HMAC 등과 함께 사용해야 합니다. 비트코인, TLS 인증서 등에 광범위하게 사용됩니다.',
                        interactive_id: 'sha256-interactive'
                    },
                    { 
                        name: 'BLAKE2 (RFC 7693)', 
                        details: 'SHA-3 경쟁 최종 후보였던 BLAKE의 후속 버전으로, HAIFA 구조에 기반하여 길이 확장 공격에 강인합니다. 특히 BLAKE2b는 64비트 플랫폼에, BLAKE2s는 32비트 이하 플랫폼에 최적화되어 있습니다. SHA-2보다 빠른 속도와 높은 유연성을 제공합니다.',
                        interactive_id: 'blake2-interactive'
                    },
                    { 
                        name: 'BLAKE3', 
                        details: 'BLAKE2를 기반으로 병렬 처리 능력을 극대화한 최신 고성능 해시 함수입니다. 내부적으로 머클 트리 구조를 사용하여 멀티코어 및 SIMD 환경에서 매우 뛰어난 성능을 발휘합니다. 스트리밍 처리, 키 해싱, 키 유도, 확장 가능 출력(XOF) 등 다양한 모드를 지원합니다. 아래에서 BLAKE3의 트리 구조를 간략히 시각화하여 병렬 처리의 이점을 살펴보세요.',
                        interactive_id: 'blake3-interactive'
                    },
                ]
            },
            symmetric: {
                title: '대칭키 암호: 신속한 데이터 기밀성 보장',
                description: '대칭키 암호 시스템은 암호화와 복호화 과정에 동일한 비밀키를 사용하는 방식입니다. 비대칭키 암호에 비해 연산 속도가 매우 빨라 대용량 데이터의 기밀성 보장에 효과적입니다. 그러나 키 분배 및 관리가 주요 과제입니다. 대표적인 표준으로는 AES가 있습니다. 아래 인터랙티브 요소를 통해 AES의 작동 방식과 운영 모드를 이해해 보세요.',
                algos: [
                    { 
                        name: 'AES (FIPS 197)', 
                        details: 'Advanced Encryption Standard의 약자로, 현재 전 세계 표준 대칭키 블록 암호입니다. 128비트 고정 블록 크기를 가지며, 키 길이에 따라 AES-128, AES-192, AES-256으로 분류됩니다. SPN(Substitution-Permutation Network) 구조를 채택하여 여러 라운드의 변환을 반복 수행합니다. 아래에서 AES 라운드 과정을 단계별로 살펴보세요.',
                        interactive_id: 'aes-rounds-interactive'
                    },
                    { 
                        name: '운영 모드 (NIST SP 800-38A)', 
                        details: '블록 암호인 AES를 실제 데이터에 적용하기 위한 방법론입니다. ECB 모드는 동일 평문 블록이 동일 암호문 블록으로 변환되어 패턴 노출에 취약합니다. CBC 모드는 이전 암호문 블록을 다음 평문 블록 암호화에 연쇄적으로 사용하여 이러한 단점을 개선합니다. 아래에서 ECB와 CBC 모드의 차이점을 시각적으로 비교해 보세요.',
                        interactive_id: 'aes-modes-interactive'
                    },
                ]
            },
            aead: {
                title: 'AEAD: 기밀성, 무결성, 인증의 통합적 제공',
                description: '인증된 암호화와 연관 데이터(AEAD)는 데이터의 기밀성, 무결성, 인증 기능을 단일 암호화 과정을 통해 통합적으로 제공하는 현대적인 암호 방식입니다. 암호화되지 않는 추가 데이터(Associated Data)의 무결성 또한 검증할 수 있습니다. 아래 인터랙티브 요소를 통해 AEAD의 처리 흐름을 확인해 보세요.',
                algos: [
                    {
                        name: 'AES-GCM (NIST SP 800-38D)',
                        details: 'AES 블록 암호를 CTR(Counter) 모드로 사용하여 암호화를 수행하고, GMAC을 통해 인증을 제공하는 널리 사용되는 AEAD 모드입니다. GMAC의 핵심인 GHASH는 유한체 GF(2^128) 상의 다항식 연산으로, 병렬 처리가 가능하여 성능이 매우 우수하며, 특히 AES-NI 하드웨어 가속을 통해 높은 처리량을 달성할 수 있습니다. TLS 1.2/1.3 등 주요 보안 프로토콜의 핵심 요소입니다.',
                        interactive_id: 'aes-gcm-interactive'
                    },
                    { 
                        name: 'ChaCha20-Poly1305 (RFC 8439)', 
                        details: '스트림 암호인 ChaCha20과 메시지 인증 코드인 Poly1305를 결합한 AEAD 구성입니다. ChaCha20은 ARX(Add-Rotate-XOR) 연산 기반으로 소프트웨어에서 높은 성능을 보이며, 특히 AES 하드웨어 가속이 없는 모바일 환경 등에서 유리합니다. Poly1305는 일회성 키를 사용하는 고속 MAC입니다. TLS 1.3의 핵심 암호 스위트 중 하나로, 논스(nonce) 재사용 금지가 매우 중요합니다.',
                        interactive_id: 'chacha20poly1305-interactive'
                    },
                    { 
                        name: 'XChaCha20-Poly1305', 
                        details: 'ChaCha20-Poly1305의 논스 길이를 96비트에서 192비트로 확장한 버전입니다. 이는 무작위 논스 생성 시 충돌 가능성을 현저히 낮추어, 대규모 분산 시스템이나 상태 관리가 어려운 환경에서 논스 관리를 용이하게 합니다. HChaCha20 함수를 사용하여 192비트 논스로부터 ChaCha20에 사용될 서브키와 단축된 논스를 파생합니다.',
                        interactive_id: 'xchacha20poly1305-interactive' 
                    },
                ]
            }
        };
        
        let currentAesStep = 0;
        const aesSteps = ['초기 상태', 'SubBytes', 'ShiftRows', 'MixColumns', 'AddRoundKey', '라운드 완료'];

        const chachaAeadSteps = ['입력 (평문, AAD, 키, 논스)', 'ChaCha20 키스트림 생성', '평문 XOR 키스트림 (암호문 생성)', 'Poly1305 인증자 계산 (AAD, 암호문)', '출력 (암호문, 인증 태그)'];
        const aesGcmAeadSteps = ['입력 (평문, AAD, 키, 논스)', 'CTR 모드 암호화', 'GHASH 계산 (AAD, 암호문)', '최종 인증 태그 생성', '출력 (암호문, 인증 태그)'];

        let blake3ChunkCount = 1;

        document.addEventListener('DOMContentLoaded', () => {
            const mainNavButtons = document.querySelectorAll('#main-nav .nav-button');
            const sections = document.querySelectorAll('.main-section');
            const algoTabButtons = document.querySelectorAll('.tab-button');
            const algoContentContainer = document.getElementById('algo-content-container');
            const timelineContainer = document.getElementById('timeline-container');

            function showSection(targetId) {
                sections.forEach(section => {
                    section.classList.toggle('hidden', section.id !== `${targetId}-section`);
                });
                mainNavButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.target === targetId);
                });
            }
            
            mainNavButtons.forEach(button => {
                button.addEventListener('click', () => {
                    showSection(button.dataset.target);
                });
            });

            function renderAlgoContent(algoType) {
                const data = algoData[algoType];
                let gridColsClass = 'md:grid-cols-1';
                if (data.algos.length === 2) {
                    gridColsClass = 'md:grid-cols-2';
                } else if (data.algos.length >= 3) {
                    gridColsClass = 'md:grid-cols-3';
                }
                
                let content = `<h3 class="text-2xl font-bold text-center mb-4 text-cyan-800">${data.title}</h3>
                               <p class="text-center text-slate-600 mb-10 max-w-3xl mx-auto">${data.description}</p>
                               <div class="grid ${gridColsClass} gap-6 max-w-7xl mx-auto">`;

                data.algos.forEach(algo => {
                    content += `<div class="content-card p-6 flex flex-col">
                                    <h4 class="font-bold text-xl mb-3 text-cyan-700">${algo.name}</h4>
                                    <p class="text-slate-600 text-sm leading-relaxed flex-grow">${algo.details}</p>
                                    <div id="${algo.interactive_id}" class="interactive-diagram mt-4"></div>
                                </div>`;
                });
                content += `</div>`;
                algoContentContainer.innerHTML = content;
                
                initInteractiveElements(algoType);
            }

            function initInteractiveElements(algoType) {
                if (algoType === 'hash') {
                    initHashInteractive('sha256-interactive', 'SHA-256', 32);
                    initHashInteractive('blake2-interactive', 'BLAKE2s', 32);
                    initBlake3Interactive('blake3-interactive');
                } else if (algoType === 'symmetric') {
                    initAesRoundsInteractive('aes-rounds-interactive');
                    initAesModesInteractive('aes-modes-interactive');
                } else if (algoType === 'aead') {
                    initAeadFlowInteractive('chacha20poly1305-interactive', 'ChaCha20-Poly1305', chachaAeadSteps, 'chacha');
                    initAeadFlowInteractive('aes-gcm-interactive', 'AES-GCM', aesGcmAeadSteps, 'aes-gcm');
                    const xchachaContainer = document.getElementById('xchacha20poly1305-interactive');
                    if(xchachaContainer) xchachaContainer.innerHTML = '<p class="text-sm text-slate-500 p-4 text-center">XChaCha20-Poly1305는 ChaCha20-Poly1305와 유사한 흐름을 가지나, 더 긴 논스를 사용하여 보안성을 강화합니다.<br>(상세 인터랙션은 ChaCha20-Poly1305 참조)</p>';
                }
            }

            function initHashInteractive(containerId, algoName, outputBytes) {
                const container = document.getElementById(containerId);
                if (!container) return;
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">${algoName} 고정 출력 시각화:</p>
                    <label for="${containerId}-input-size" class="text-xs">가상 입력 데이터 크기 (바이트): <span id="${containerId}-input-value">100</span></label>
                    <input type="range" id="${containerId}-input-size" min="1" max="1000" value="100" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                    <p class="text-xs mt-2">입력 (가상): <span id="${containerId}-input-display" class="font-mono bg-white p-1 rounded break-all">데이터... (100 바이트)</span></p>
                    <p class="text-xs mt-1">출력 (${algoName} 해시, ${outputBytes * 8}비트): <span id="${containerId}-output-display" class="font-mono bg-white p-1 rounded break-all">${'...'.repeat(outputBytes)}</span></p>
                    <p class="text-xs text-slate-500 mt-1">입력 크기가 변경되어도 출력 해시의 길이는 항상 ${outputBytes}바이트(${outputBytes*8}비트)로 고정됩니다.</p>
                `;
                const inputSizeSlider = document.getElementById(`${containerId}-input-size`);
                const inputValueDisplay = document.getElementById(`${containerId}-input-value`);
                const inputDisplay = document.getElementById(`${containerId}-input-display`);
                const outputDisplay = document.getElementById(`${containerId}-output-display`);

                inputSizeSlider.addEventListener('input', (e) => {
                    const size = e.target.value;
                    inputValueDisplay.textContent = size;
                    inputDisplay.textContent = `데이터... (${size} 바이트)`;
                    let mockHash = '';
                    for(let i=0; i<outputBytes; i++) {
                        mockHash += Math.floor(Math.random()*256).toString(16).padStart(2,'0').substring(0,1);
                    }
                    outputDisplay.textContent = mockHash.substring(0, outputBytes) + (outputBytes > 16 ? '...' : '');

                });
                let mockInitialHash = '';
                for(let i=0; i<outputBytes; i++) { mockInitialHash += 'X'; }
                outputDisplay.textContent = mockInitialHash;
            }

            function initBlake3Interactive(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                blake3ChunkCount = 1; 

                function renderBlake3Tree() {
                    let treeHtml = '<p class="text-sm font-medium mb-2">BLAKE3 트리 구조 (개념적):</p>';
                    treeHtml += '<div class="flex flex-col items-center">';
                    
                    let currentLevelNodes = [];
                    for(let i=0; i < blake3ChunkCount; i++) {
                        currentLevelNodes.push(`<div class="blake3-node ${i === 0 && blake3ChunkCount > 1 ? '' : (blake3ChunkCount === 1 ? 'active' : '')}">청크 ${i+1}</div>`);
                    }

                    let level = 0;
                    while(currentLevelNodes.length > 1 || level === 0 && currentLevelNodes.length === 1) {
                        treeHtml += `<div class="flex justify-center my-1">${currentLevelNodes.join('')}</div>`;
                        if (currentLevelNodes.length === 1 && level > 0) break;

                        const parentNodes = [];
                        for(let i=0; i < currentLevelNodes.length; i+=2) {
                            if (i + 1 < currentLevelNodes.length) {
                                parentNodes.push(`<div class="blake3-node ${currentLevelNodes.length <= 2 ? 'active' : ''}">부모</div>`);
                            } else {
                                parentNodes.push(currentLevelNodes[i]);
                            }
                        }
                        currentLevelNodes = parentNodes;
                        level++;
                        if (level > 4) break;
                    }
                     if (currentLevelNodes.length === 1 && level > 0) {
                         treeHtml += `<div class="flex justify-center my-1">${currentLevelNodes[0].replace('부모', '루트 해시')}</div>`;
                     }

                    treeHtml += '</div>';
                    treeHtml += `<div class="mt-2 text-center">
                                    <button id="addBlake3Chunk" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">청크 추가</button>
                                    <button id="resetBlake3Tree" class="text-xs bg-slate-500 hover:bg-slate-600 text-white py-1 px-2 rounded">초기화</button>
                                 </div>`;
                    treeHtml += '<p class="text-xs text-slate-500 mt-1 text-center">각 청크는 병렬로 해시된 후, 트리 구조로 병합되어 최종 루트 해시를 생성합니다.</p>';
                    container.innerHTML = treeHtml;

                    document.getElementById('addBlake3Chunk').addEventListener('click', () => {
                        if (blake3ChunkCount < 8) blake3ChunkCount++;
                        renderBlake3Tree();
                    });
                    document.getElementById('resetBlake3Tree').addEventListener('click', () => {
                        blake3ChunkCount = 1;
                        renderBlake3Tree();
                    });
                }
                renderBlake3Tree();
            }

            function initAesRoundsInteractive(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                currentAesStep = 0;
                
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">AES 라운드 과정 (개념적):</p>
                    <div class="flex justify-around items-center mb-2 flex-wrap">
                        ${aesSteps.map((step, index) => `<div id="aes-step-${index}" class="aes-step text-xs">${step}</div>`).join('')}
                    </div>
                    <div id="aes-state-matrix" class="grid grid-cols-4 gap-1 p-2 bg-white border border-slate-300 rounded w-max mx-auto mb-2">
                        ${Array(16).fill(0).map((_, i) => `<div class="data-block" id="aes-byte-${i}">B${i}</div>`).join('')}
                    </div>
                    <div class="text-center">
                        <button id="nextAesStep" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">다음 단계</button>
                        <button id="resetAesSteps" class="text-xs bg-slate-500 hover:bg-slate-600 text-white py-1 px-2 rounded">초기화</button>
                    </div>
                    <p id="aes-step-description" class="text-xs text-slate-500 mt-1 text-center">버튼을 눌러 AES 라운드 단계를 진행하세요.</p>
                `;

                const stepElements = aesSteps.map((_, index) => document.getElementById(`aes-step-${index}`));
                const stateMatrixBytes = Array(16).fill(0).map((_, i) => document.getElementById(`aes-byte-${i}`));
                const descriptionElement = document.getElementById('aes-step-description');

                function updateAesVisual() {
                    stepElements.forEach((el, idx) => el.classList.toggle('active', idx === currentAesStep));
                    stateMatrixBytes.forEach(byteEl => { byteEl.style.backgroundColor = 'white'; byteEl.style.color = '#1e293b';});
                    let desc = "";
                    if (currentAesStep === 0) desc = "초기 상태: 128비트 데이터 블록 (4x4 바이트 행렬)";
                    else if (currentAesStep === 1) { desc = "SubBytes (비선형성): 각 바이트를 S-Box를 이용해 치환하여 혼돈(confusion)을 증가시킵니다."; stateMatrixBytes.forEach(byteEl => { byteEl.style.backgroundColor = '#bae6fd'; byteEl.style.color = '#0c4a6e'; }); }
                    else if (currentAesStep === 2) { desc = "ShiftRows (확산): 각 행의 바이트들을 왼쪽으로 순환 이동시켜 데이터를 확산시킵니다."; for(let r=1; r<4; r++) for(let c=0; c<4; c++) stateMatrixBytes[r*4+c].style.backgroundColor = '#7dd3fc'; }
                    else if (currentAesStep === 3) { desc = "MixColumns (확산): 각 열의 바이트들을 선형 혼합하여 확산을 더욱 강화합니다."; for(let c=0; c<4; c++) for(let r=0; r<4; r++) stateMatrixBytes[r*4+c].style.backgroundColor = '#38bdf8'; }
                    else if (currentAesStep === 4) { desc = "AddRoundKey (키 혼합): 현재 상태와 라운드 키를 XOR 연산합니다."; stateMatrixBytes.forEach(byteEl => { byteEl.style.backgroundColor = '#0ea5e9'; byteEl.style.color = 'white';}); }
                    else if (currentAesStep === 5) desc = "라운드 완료. 이 과정이 키 길이에 따라 10~14회 반복됩니다.";
                    descriptionElement.textContent = desc;
                }

                document.getElementById('nextAesStep').addEventListener('click', () => { currentAesStep = (currentAesStep + 1) % aesSteps.length; updateAesVisual(); });
                document.getElementById('resetAesSteps').addEventListener('click', () => { currentAesStep = 0; updateAesVisual(); });
                updateAesVisual();
            }

            function initAesModesInteractive(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                const renderModeBlocks = (mode) => {
                    let html = '';
                    const patterns = { ecb_plain: [0,0,1,1,0,0,2,2], ecb_cipher: [0,0,1,1,0,0,2,2], cbc_plain: [0,0,1,1,0,0,2,2], cbc_cipher: [3,4,5,6,7,8,9,10] };
                    const colors = ['bg-red-200', 'bg-green-200', 'bg-blue-200', 'bg-yellow-300', 'bg-purple-300', 'bg-pink-300', 'bg-indigo-300', 'bg-teal-300', 'bg-orange-300', 'bg-lime-300', 'bg-cyan-300'];
                    const data = mode === 'ecb' ? patterns.ecb_cipher : patterns.cbc_cipher; const plainData = patterns.ecb_plain;
                    html += '<p class="text-xs mb-1">평문 블록:</p><div class="flex flex-wrap mb-2">';
                    plainData.forEach(p => { html += `<div class="data-block ${colors[p % colors.length]}">P${p}</div>`; });
                    html += '</div>';
                    html += '<p class="text-xs mb-1">암호문 블록:</p><div class="flex flex-wrap">';
                    data.forEach(d => { html += `<div class="data-block ${colors[d % colors.length]}">C${d}</div>`; });
                    html += '</div>'; return html;
                };
                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">AES 운영 모드 비교 (ECB vs CBC):</p>
                    <div class="flex justify-center mb-2">
                        <button id="showEcb" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded mr-2">ECB 보기</button>
                        <button id="showCbc" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">CBC 보기</button>
                    </div><div id="aesModeDisplay" class="p-2 bg-white border border-slate-300 rounded">${renderModeBlocks('ecb')}</div>
                    <p id="aesModeDescription" class="text-xs text-slate-500 mt-1 text-center">ECB 모드는 동일 평문 블록이 동일 암호문 블록으로 변환되어 패턴이 노출됩니다.</p>`;
                const displayDiv = document.getElementById('aesModeDisplay'); const descriptionP = document.getElementById('aesModeDescription');
                document.getElementById('showEcb').addEventListener('click', () => { displayDiv.innerHTML = renderModeBlocks('ecb'); descriptionP.textContent = "ECB 모드는 동일 평문 블록이 동일 암호문 블록으로 변환되어 패턴이 노출됩니다."; });
                document.getElementById('showCbc').addEventListener('click', () => { displayDiv.innerHTML = renderModeBlocks('cbc'); descriptionP.textContent = "CBC 모드는 이전 암호문의 영향을 받아 동일 평문 블록이라도 다른 암호문 블록으로 변환되어 패턴이 숨겨집니다."; });
            }

            function initAeadFlowInteractive(containerId, algoName, steps, type) {
                const container = document.getElementById(containerId);
                if (!container) return;
                let currentStep = 0;

                container.innerHTML = `
                    <p class="text-sm font-medium mb-2">${algoName} 처리 흐름 (개념적):</p>
                    <div class="flex flex-col items-center space-y-1 mb-2">
                        ${steps.map((step, index) => `<div id="${type}-step-${index}" class="aead-flow-step text-xs w-full text-center">${step}</div>`).join('<div class="text-2xl self-center text-slate-400">&darr;</div>')}
                    </div>
                     <div class="text-center">
                        <button id="next-${type}-step" class="text-xs bg-cyan-500 hover:bg-cyan-600 text-white py-1 px-2 rounded">다음 단계</button>
                        <button id="reset-${type}-steps" class="text-xs bg-slate-500 hover:bg-slate-600 text-white py-1 px-2 rounded">초기화</button>
                    </div>
                    <p id="${type}-step-description" class="text-xs text-slate-500 mt-1 text-center">버튼을 눌러 AEAD 처리 단계를 진행하세요.</p>
                `;
                
                const stepElements = steps.map((_, index) => document.getElementById(`${type}-step-${index}`));
                const descriptionElement = document.getElementById(`${type}-step-description`);

                const descriptions = {
                    'chacha': [
                        "입력: 평문, 부가 인증 데이터(AAD), 암호화 키, 그리고 고유한 논스(Nonce)가 준비됩니다.",
                        "키스트림 생성: ChaCha20을 사용하여 키와 논스로부터 키스트림을 생성합니다.",
                        "암호화: 생성된 키스트림과 평문을 XOR하여 암호문을 만듭니다. (기밀성 확보)",
                        "인증자 계산: Poly1305를 사용하여 AAD와 암호문으로부터 인증 태그를 계산합니다. (무결성 및 인증 확보)",
                        "출력: 최종적으로 암호문과 인증 태그가 생성됩니다. 수신자는 이 두 가지를 모두 검증합니다."
                    ],
                    'aes-gcm': [
                        "입력: 평문, 부가 인증 데이터(AAD), 암호화 키, 그리고 고유한 논스(Nonce/IV)가 준비됩니다.",
                        "CTR 모드 암호화: AES와 카운터(논스 기반)를 이용해 키스트림을 생성하고 평문과 XOR하여 암호문을 생성합니다.",
                        "GHASH 계산: AAD와 암호문을 유한체(Galois Field) 상에서 곱셈(GHASH)하여 중간 인증값을 계산합니다.",
                        "최종 인증 태그 생성: GHASH 결과값을 암호화하여 최종 인증 태그(GMAC)를 생성합니다.",
                        "출력: 암호문과 최종 인증 태그가 함께 생성됩니다. 수신자는 복호화와 태그 검증을 병렬로 수행할 수 있습니다."
                    ]
                };

                function updateVisual() {
                    stepElements.forEach((el, idx) => el.classList.toggle('active', idx === currentStep));
                    descriptionElement.textContent = descriptions[type][currentStep];
                }

                document.getElementById(`next-${type}-step`).addEventListener('click', () => { currentStep = (currentStep + 1) % steps.length; updateVisual(); });
                document.getElementById(`reset-${type}-steps`).addEventListener('click', () => { currentStep = 0; updateVisual(); });
                updateVisual();
            }

            algoTabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    algoTabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    renderAlgoContent(button.dataset.algoTarget);
                });
            });
            
            function renderTimeline() {
                let html = '';
                timelineData.forEach(item => {
                    html += `<div class="timeline-item">
                                <div class="timeline-dot"></div>
                                <time class="mb-1 text-sm font-normal leading-none text-slate-500">${item.year}</time>
                                <h3 class="text-lg font-semibold text-cyan-800">${item.title}</h3>
                                <p class="text-base font-normal text-slate-600">${item.description}</p>
                             </div>`;
                });
                timelineContainer.innerHTML = html;
            }

            renderTimeline();
            renderAlgoContent('hash'); 

            const securityCtx = document.getElementById('securityChart').getContext('2d');
            new Chart(securityCtx, {
                type: 'bar',
                data: {
                    labels: ['AES-128', 'AES-256', 'SHA-256', 'SHA-512', 'ML-KEM-512 (NIST L1)', 'ML-DSA-44 (NIST L2)'],
                    datasets: [{
                        label: '고전적 등가 보안 강도 (비트)',
                        data: [128, 256, 128, 256, 128, 128], 
                        backgroundColor: '#06b6d4',
                        borderColor: '#0891b2',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    label += `${context.raw} 비트`;
                                    if (context.label.includes('ML-KEM')) label += ' (vs AES-128)';
                                    if (context.label.includes('ML-DSA')) label += ' (vs SHA-256)';
                                    return label;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: '알고리즘별 고전적 보안 강도 (NIST 기준 등가)'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: '보안 비트 수' }
                        }
                    }
                }
            });

            const speedCtx = document.getElementById('speedChart').getContext('2d');
            new Chart(speedCtx, {
                type: 'bar',
                data: {
                    labels: ['SHA-256', 'SHA-512', 'BLAKE2s', 'BLAKE3 (single-thread)', 'AES-256-GCM (NI)', 'ChaCha20-Poly1305'],
                    datasets: [{
                        label: '상대적 연산 속도 (높을수록 우수)',
                        data: [60, 40, 80, 100, 90, 85], 
                        backgroundColor: ['#67e8f9', '#22d3ee', '#06b6d4', '#0891b2', '#0e7490', '#164e63'],
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.x !== null) {
                                        label += `${context.parsed.x} (상대값)`;
                                    }
                                    return label;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: '소프트웨어 구현 기반 상대적 성능 (일반 CPU 환경 기준)'
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: { display: true, text: '성능 지표 (상대값)' }
                        }
                    }
                }
            });
        });
    </script>
</body>
</html>
